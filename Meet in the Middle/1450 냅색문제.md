Tags: `BOJ`, `Meet-in-the-Middle` `knapsack`
# [BOJ] 1450번 냅색문제 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.09.01
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초 | 128MB | 7692 | 2909 | 2154  | 38.300% |

### 문제
---
세준이는 N개의 물건을 가지고 있고, 최대 C만큼의 무게를 넣을 수 있는 가방을 하나 가지고 있다.

N개의 물건을 가방에 넣는 방법의 수를 구하는 프로그램을 작성하시오.

### 입력
---
첫째 줄에 N과 C가 주어진다. N은 30보다 작거나 같은 자연수, C는 109보다 작거나 같은 음이 아닌 정수이다. 둘째 줄에 물건의 무게가 주어진다. 무게도 109보다 작거나 같은 자연수이다.

### 출력
---
첫째 줄에 가방에 넣는 방법의 수를 출력한다.

### 예제입력1
```
30 30
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
### 예제출력1
```
1073741824
```
## 2. 소스코드

### 알고리즘
이 문제를 풀면서 두가지 문제에 직면하였다. 먼저 이전까지 풀어오던 방식과 다르게 연속된 순서쌍이 아니라 비연속적인 조합이 포함된다. 또한, 최대 조합의 수가 $2^{30}$ 개이다. 그냥 문제를 풀면 시간초과가 발생하기 때문에 문제에서 주어진 배열을 두개로 나누어 문제를 풀면 최대 경우의 수가 $2^{15}$로 줄어들게 된다. 

그래서 먼저 주어진 배열을 두개로 나누어 가능한 합 조합을 모두 저장한다. 그리고, 저장한 합 배열에서 한 순차적으로 합a를 고르고, 다른 배열에서 합b를 고른다. a+b가 c보다 작은 경우의 수를 세면 된다. 
여기서도 단순하게 탐색을 진행하면 O($n^2$)의 시간이 소요되므로, 이진탐색을 통해 시간을 줄인다. 
이때 배열에서 중복이 포함되어 있기 때문에 일반적인 이진탐색이 아닌 다른 방법을 사용한다. 같은 수를 찾을 때 탐색을 종료하는 조건을 제외하고 탐색을 수행하면 주어진 수보다 작은 모든 수의 개수를 찾을 수 있다.  
이를 통해 탐색을 O(nlogn)으로 줄여 시간을 단축할 수 있다. 순서적으로 나열하면 다음과 같은 작업이 된다.

1. 주어진 배열을 두 개의 배열로 나눈 후 각각에서 가능한 조합을 모두 세서 a, b에 저장한다.
2. 이진탐색을 수행하기 위해 배열 a, b 중 이진탐색이 수행될 배열을 정렬한다.
3. 그 후 정렬되지 않은 배열의 원소들을 순차적으로 방문한다.
4. 방문한 원소가 c보다 크거나 같을 때 c-방문한 원소보다 작은 수의 개수를 이진탐색으로 배열 b에서 찾는다.
5. 찾은 작은 수의 개수를 변수에 누적에서 더한다.
6. 누적해서 더해진 변수는 가능한 조합의 개수가 된다. 

### 코드
```Python
def binary_search(array, target):
    l, r = 0, len(array)-1
    while l <= r:
        m = (l+r)//2
        if array[m] > target:
            r = m - 1
        else:
            l = m + 1
    return l


def problem1450():
    n, c = map(int, input().split())
    weights = list(map(int, input().split()))
    weights.sort()
    left, right = [], []

    def left_find(x, cnt):
        if x == n//2:
            left.append(cnt)
            return
        left_find(x + 1, cnt)
        left_find(x + 1, cnt + weights[x])

    def right_find(x, cnt):
        if x == n:
            right.append(cnt)
            return
        right_find(x + 1, cnt)
        right_find(x + 1, cnt + weights[x])

    left_find(0, 0)
    right_find(n//2, 0)
    right.sort()
    cnt = 0
    for i in range(len(left)):
        if c >= left[i]:
            cnt += binary_search(right, c-left[i])

    print(cnt)


problem1450()

```

|  결과   |   메모리   |  시간   | 코드길이 |
| :---: | :-----: | :---: | :--: |
| 맞았습니다 | 34596KB | 116ms | 905B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
