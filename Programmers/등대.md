# [Programmers] 등대 (PYTHON)
Programmers 코딩테스트 연습: 

ID: yuchem2@gmail.com

Date: 2025.01.06

소요시간: 1시간

## 1. 문제설명

### 문제
---

인천 앞바다에는 1부터 n까지 서로 다른 번호가 매겨진 등대 n개가 존재합니다. 등대와 등대 사이를 오가는 뱃길이 n-1개 존재하여, 어느 등대에서 출발해도 다른 모든 등대까지 이동할 수 있습니다. 등대 관리자 윤성이는 전력을 아끼기 위하여, 이 중 몇 개의 등대만 켜 두려고 합니다. 하지만 등대를 아무렇게나 꺼버리면, 뱃길을 오가는 배들이 위험할 수 있습니다. 한 뱃길의 양쪽 끝 등대 중 적어도 하나는 켜져 있도록 등대를 켜 두어야 합니다.

예를 들어, 아래 그림과 같이 등대 8개와 7개의 뱃길들이 있다고 합시다. 이 경우 1번 등대와 5번 등대 두 개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있으므로, 배들은 안전하게 운항할 수 있습니다.

![image](https://github.com/user-attachments/assets/9ecafdf5-bd8f-49b3-b8c0-e9e7d8a51685)


등대의 개수 n과 각 뱃길이 연결된 등대의 번호를 담은 이차원 배열 lighthouse가 매개변수로 주어집니다. 윤성이가 켜 두어야 하는 등대 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항
+ 2 ≤ n ≤ 100,000
+ lighthouse의 길이 = n – 1
  + lighthouse 배열의 각 행 [a, b]는 a번 등대와 b번 등대가 뱃길로 연결되어 있다는 의미입니다.
  + 1 ≤ a ≠ b ≤ n
  + 모든 등대는 서로 다른 등대로 이동할 수 있는 뱃길이 존재하도록 입력이 주어집니다.

### 예제입출력

| n  | lighthouse                                                                | result  |
|----|---------------------------------------------------------------------------|---------|
| 8  | [[1, 2], [1, 3], [1, 4], [1, 5], [5, 6], [5, 7], [5, 8]]                  | 2       |
| 10 | [[4, 1], [5, 1], [5, 6], [7, 6], [1, 2], [1, 3], [6, 8], [2, 9], [9, 10]] | 3       |


## 2. 소스코드

### 알고리즘
해당 문제에서 가장 먼저 떠오른 경우는 다음과 같다.

1. 모든 리프 노드는 불이 꺼져있는 것이 좋다. (최소를 만족하기 위해)
2. 리프 노드를 자식으로 갖는 노드는 켜져있는 것 이 좋다. (1번 조건에 따라 문제 조건을 만족하기 위해)
3. 리프노드가 아닌 자식 노드를 갖는 부모 노드는 각 상황에 따라 켜지고 꺼지는 것이 좋다.

이 경우를 토대로 문제를 접근한다고 생각했을 때 임의의 노드를 루트 노드로 하는 트리라고 생각한 후 dp를 이용해 문제를 해결할 수 있다고 생각했다.

+ n * 2 크기를 가지는 임의의 dp 배열을 다음과 같이 정의한다.
  + dp[node][0] = node를 루트로 하는 서브트리가 node의 불이 꺼져있을 때 불이 켜져있는 노드들의 최소값
  + dp[node][1] = node를 루트로 하는 서브트리가 node의 불이 켜져있을 때 불이 켜져있는 노드들의 최소값
+ 후위 탐색을 통해 임의의 루트를 선정한 후 리프노드부터 탐색을 진행한다.
+ 모든 자식에 대한 탐색이 끝난 부모 노드에서 dp 값을 다음과 같이 계산한다.
  + node는 임의의 부모 노드, child는 그 부모노드의 모든 자식노드들을 말함.  
  + dp[node][0] = sum(min(dp[child][0], dp[child][1])) + 1 
  + dp[node][1] = sum(dp[child][1])

이러한 가정을 통해 문제를 풀면 해결할 수 있다.

### 코드
```python
def solution(n, lighthouse):    
    tree = [[] for _ in range(n)]
    for st, end in lighthouse:
        tree[st-1].append(end)
        tree[end-1].append(st)

    dp = [[0, 0] for _ in range(n)]
    visited = [0] * n
    stack = [1]
    while stack:
        cur = stack.pop()
        if cur > 0:
            visited[cur-1] = 1
            stack.append(-cur)
            for nxt in tree[cur-1]:
                if not visited[nxt-1]:
                    stack.append(nxt)
        else:
            cur = -cur
            for nxt in tree[cur-1]:
                if dp[nxt-1][0] > 0:
                    dp[cur-1][0] += min(dp[nxt-1][0], dp[nxt-1][1])
                    dp[cur-1][1] += dp[nxt-1][0]
            dp[cur-1][0] += 1

    return min(dp[0])
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
