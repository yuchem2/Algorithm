# [Programmers] 공 이동 시뮬레이션 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/87391

ID: yuchem2@gmail.com

Date: 2025.05.14

소요시간: 2시간 30분

## 1. 문제설명

### 문제
---
n행 m열의 격자가 있습니다. 격자의 각 행은 0, 1, ..., n-1번의 번호, 그리고 각 열은 0, 1, ..., m-1번의 번호가 순서대로 매겨져 있습니다. 당신은 이 격자에 공을 하나 두고, 그 공에 다음과 같은 쿼리들을 날리고자 합니다.

+ 열 번호가 감소하는 방향으로 dx칸 이동하는 쿼리 (query(0, dx))
+ 열 번호가 증가하는 방향으로 dx칸 이동하는 쿼리 (query(1, dx))
+ 행 번호가 감소하는 방향으로 dx칸 이동하는 쿼리 (query(2, dx))
+ 행 번호가 증가하는 방향으로 dx칸 이동하는 쿼리 (query(3, dx))

단, 공은 격자 바깥으로 이동할 수 없으며, 목적지가 격자 바깥인 경우 공은 이동하다가 더 이상 이동할 수 없을 때 멈추게 됩니다. 예를 들어, 5행 × 4열 크기의 격자 내의 공이 3행 2열에 있을 때 query(3, 10) 쿼리를 받은 경우 공은 4행 2열에서 멈추게 됩니다. (격자의 크기가 5행 × 4열이므로, 0~4번 행과 0~3번 열로 격자가 구성되기 때문입니다.)

격자의 행의 개수 n, 열의 개수 m, 정수 x와 y, 그리고 쿼리들의 목록을 나타내는 2차원 정수 배열 queries가 매개변수로 주어집니다. n × m개의 가능한 시작점에 대해서 해당 시작점에 공을 두고 queries 내의 쿼리들을 순서대로 시뮬레이션했을 때, x행 y열에 도착하는 시작점의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
+ 1 ≤ n ≤ $10^9$
+ 1 ≤ m ≤ $10^9$
+ 0 ≤ x < n
+ 0 ≤ y < m
+ 1 ≤ queries의 행의 개수 ≤ 200,000
  + queries의 각 행은 [command,dx] 두 정수로 이루어져 있습니다.
  + 0 ≤ command ≤ 3
  + 1 ≤ dx ≤ 109
  + 이는 query(command, dx)를 의미합니다.

### 예제입출력

| n | m | x | y | queries                               | result  |
|---|---|---|---|---------------------------------------|---------|
| 2 | 2 | 0 | 0 | [[2,1],[0,1],[1,1],[0,1],[2,1]]       | 4       |
| 2 | 5 | 0 | 1 | [[3,1],[2,2],[1,1],[2,3],[0,1],[2,1]] | 2       |

## 2. 소스코드

### 알고리즘
격자의 임의의 지점에서 (x, y)로 이동하는 모든 경우의 수를 찾으려면 주어진 제한사항에서는 불가능하다. 그러므로, (x, y)에서 queries의 맨 뒤부터 시작해 반대로 시뮬레이션을 하는 게 좋다. 

예제입출력 1번에서의 예시를 보면, (0, 0)에 query(2, 1)로 도달할 수 있는 좌표는 (0, 0)과 (0, 1)이다. 그 다음에는 (0, 0), (0, 1)에 query(0, 1)로 도달할 수 있는 좌표들을 찾는 것이다.

이런 개념을 잡고 단순하게 시뮬레이션을 수행해 문제를 해결하고자 했으나, 이 경우 문제의 제한사항에서 격자 크기가 최대 $10^9 * 10^9$이므로, 시간초과가 발생할 가능성이 크다. 

그래서 다시 생각해보면 도달할 수 있는 좌표를 배열로 관리하는 것이 아니라 직사각형으로 접근하면 실행시간을 O(len(queries))로 줄일 수 있기 때문에 이 접근법으로 문제를 해결하였다.

해당 문제에서는 항상 상하좌우로 이동하기 때문에 특정 지점에 특정 쿼리로 접근할 수 있는 좌표의 범위는 무조건 직사각형으로 구성되는 것을 알 수 있다. (그림을 그려보거나 문제에 삽입된 gif를 확인하면 인지할 수 있다.)

직사각형을 좌상단, 우하단의 두 개의 좌표로 구성해 문제를 풀면 풀릴 것으로 접근하고 문제를 접근하였다. 그러나 연산을 너무 어렵게 생각하는 바람에... 연산 규칙을 정하는 데 너무 많은 시간이 소요되었다. (앞으로 문제 풀이할 때 개선이 필요)

--- 
연산 규칙은 열과 행 상관없이 증가하거나 감소하는 것에서 결정을 하면 된다. *(행 or 열)

*이 감소하는 경우 현재 값보다 큰 값에서 접근한다는 것을 의미한다. 그러므로, 현재 직사각형보다 오른쪽에 있는 값을 찾아야 한다. (v + dv)
감소하는 경우 좌상단의 좌표가 주어진 격자 범위보다 크면 직사각형 모두가 좌표 밖이므로, 유효한 지점이 없다.
우하단의 좌표가 주어진 격자 범위보다 크면 직사각형의 일부가 좌표 밖에 있다는 것이므로, 우상단의 좌표는 격자의 *의 최댓값이 된다.

*이 증가하는 경우 현재 값보다 작은 값에서 접근한다는 것을 의미한다. 그러므로, 현재 직사각형보다 왼쪽에 있는 값을 찾아야 한다. (v - dv)
감소하는 경우 우하단의 좌표가 주어진 격자 범위보다 작으면 직사각형 모두가 좌표 밖이므로, 유효한 지점이 없다.
좌상단의 좌표가 주어진 격자 범위보다 작으면 직사각형의 일부가 좌표 밖에 있다는 것이므로, 좌상단의 좌표는 격자 *의 최솟값(0)이 된다.

위 규측을 토대로 코드를 작성하면 문제를 해결할 수 있다.

### 코드
```python
def solution(n, m, x, y, queries):
    x1, x2, y1, y2 = x, x, y, y
    for i in range(len(queries) - 1, -1, -1): 
        d, dv = queries[i]
        
        if d == 0: # 열이 감소 => 현재 값보다 큰 값들에서 접근
            y1 = y1 if y1 == 0 else y1 + dv
            y2 = y2 + dv
            if y1 > m - 1: return 0
            elif y2 > m - 1: y2 = m - 1
            
        elif d == 1: # 열이 증가 => 현재 값보다 작은 값들에서 접근
            y1 = y1 - dv
            y2 = y2 if y2 == m - 1 else y2 - dv
            if y2 < 0: return 0
            elif y1 < 0: y1 = 0 
            
        elif d == 2: # 행이 감소 => 현재 값보다 큰 값들에서 접근
            x1 = x1 if x1 == 0 else x1 + dv
            x2 = x2 + dv
            if x1 > n - 1: return 0
            elif x2 > n - 1: x2 = n - 1   
            
        else: # 행이 증가 => 현재 값보다 큰 값들에서 접근
            x1 = x1 - dv
            x2 = x2 if x2 == n - 1 else x2 - dv
            if x2 < 0: return 0
            elif x1 < 0: x1 = 0
                
    return (x2 - x1 + 1) * (y2 - y1 + 1)
```
## 3. 개선점

## 4. 개선사항

## 5. 개선사항 평가
