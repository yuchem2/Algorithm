# [Programmers] 행렬과 연산 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/118670

ID: yuchem2@gmail.com

Date: 2025.05.17

소요시간: 30분

## 1. 문제설명

### 문제
---
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

당신은 행렬에 적용할 수 있는 두 가지 연산을 만들었습니다.

+ ShiftRow
  + 모든 행이 아래쪽으로 한 칸씩 밀려납니다. 즉, 모든 행에 대해서 i번째 행은 i+1번째 행이 됩니다. (마지막 행은 1번째 행이 됩니다.)
  + ShiftRow의 예 ![image](https://github.com/user-attachments/assets/07c9b38b-f562-440c-a379-0b25630a5487)
    + 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 ShiftRow를 한 번 시행한 뒤의 행렬입니다.
    + 1번째 행에 있던 [1,2,3]이 2번째 행으로, 2번째 행에 있던 [4,5,6]이 3번째 행으로, 3번째 행에 있던 [7,8,9]가 1번째 행이 된 것을 확인할 수 있습니다.
+ Rotate
  + 행렬의 바깥쪽에 있는 원소들을 시계 방향으로 한 칸 회전시킵니다.
  + 행렬의 바깥쪽에 있는 원소들은 첫 행, 첫 열, 끝 행, 끝 열에 포함되는 원소들입니다.
  + 한 칸 회전시킨다는 것은 이 원소들이 시계 방향으로 한 칸씩 밀려난다는 것을 의미합니다. 즉, 다음 4개의 연산이 동시에 시행됩니다.
    + 첫 행에서 끝 열에 있는 원소를 제외한 첫 행의 모든 원소는 오른쪽으로 한 칸 이동합니다.
    + 끝 열에서 끝 행에 있는 원소를 제외한 끝 열의 모든 원소는 아래쪽으로 한 칸 이동합니다.
    + 끝 행에서 첫 열에 있는 원소를 제외한 끝 행의 모든 원소는 왼쪽으로 한 칸 이동합니다.
    + 첫 열에서 첫 행에 있는 원소를 제외한 첫 열의 모든 원소는 위쪽으로 한 칸 이동합니다.
  + Rotate의 예 ![image](https://github.com/user-attachments/assets/7fc39dc8-dcde-4b46-bd4e-8694c87b85d0)
    + 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 Rotate를 한 번 시행한 뒤의 행렬입니다.
    + 바깥쪽에 있는 값들이 시계 방향으로 한 칸씩 이동한 것을 확인할 수 있습니다.

당신은 행렬에 연산을 여러 번 시행하려고 합니다.

행렬의 초기 상태를 담고 있는 2차원 정수 배열 rc, 시행할 연산을 순서대로 담고 있는 문자열 배열 operations가 매개변수로 주어졌을 때, 연산을 차례대로 시행한 후의 행렬 상태를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
+ 2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 50,000
  + rc의 모든 행의 길이는 동일합니다.
+ 2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 50,000
  + rc의 모든 열의 길이는 동일합니다.
+ 4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 100,000
+ rc[i][j] 는 i+1번째 행 j+1번째 열에 있는 원소를 나타냅니다.
  + 1 ≤ rc[i][j] ≤ 1,000,000
+ 1 ≤ operations의 길이 ≤ 100,000
  + operations의 원소는 "ShiftRow" 혹은 "Rotate"입니다.

정확성 테스트 케이스 제한 사항
+ 2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 1,000
  + rc의 모든 행의 길이는 동일합니다.
+ 2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 1,000
  + rc의 모든 열의 길이는 동일합니다.
+ 4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 10,000
+ 1 ≤ operations의 길이 ≤ 100

효율성 테스트 케이스 제한 사항
+ 주어진 조건 외 추가 제한사항 없습니다.

### 예제입출력
| rc                                            | operations                                   | result                                        |
|-----------------------------------------------|----------------------------------------------|-----------------------------------------------|
| [[1, 2, 3], [4, 5, 6], [7, 8, 9]]             | ["Rotate", "ShiftRow"]                       | [[8, 9, 6], [4, 1, 2], [7, 5, 3]]             |
| [[8, 6, 3], [3, 3, 7], [8, 4, 9]]             | ["Rotate", "ShiftRow", "ShiftRow"]           | [[8, 3, 3], [4, 9, 7], [3, 8, 6]]             |
| [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] | ["ShiftRow", "Rotate", "ShiftRow", "Rotate"] | [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]] |

## 2. 소스코드

### 알고리즘
해당 문제를 풀 때는 다음과 같은 과정으로 풀었다. 
1. 정확성 만족하기
2. 정확성 만족 후 효율성 만족하기

위 문제에서 주어지는 행렬의 크기를 n x m으로 정의하고, 명령의 수를 k라고 정의하고 문제를 풀었다.

맨 처음 정확성을 만족하는 풀이를 확인하기 위해 단순하게 주어진 행렬에 명령을 시뮬레이션 하는 방식으로 문제를 풀었다.
+ shiftRow는 맨 아래 행을 맨 위로 올리면 되도록 slicing을 활용해 문제를 해결하였다. O(n - 1) 소요
+ rotate는 행을 3가지로 쪼개서 문제를 해결하였다. 각 연산에는 모두 slicing이 필요해 총 O(n * (m - 1)) 소요
+ 즉 총 소요시간은 O(k * n * m)가 되며 최대값으로 생각해보면 연산량은 $10^{10}$ 으로 시간초과가 발생할 여지가 매우 높다.

위 방식으로 정확하게 문제를 시뮬레이션할 수 있었으나, 소요시간을 줄이는 것이 중요해 보였다. 그래서 위에서 제일 많은 시간이 소요되는 rotate 연산의 시간을 줄일 필요가 있었다.
rotate에서 행으로만 접근하면 문제를 푸는 데 모든 행에 대해 접근을 해야해서 O(n * m)이 소요된다. 그러므로 주어진 행렬을 다음과 같은 방법으로 쪼개서 생각하였다.
+ 첫번째 열
+ 마지막 열
+ 첫번째 열과 마지막 열을 제외한 나머지 열은 행으로 한번에 관리 

즉, 예시 첫번째 입력으로 생각하면 다음과 같이 3개의 list로 관리를 진행하였다. `[1, 4, 7], [3, 6, 9], [[2], [5], [9]]` 이렇게 행렬을 나눠서 관리하면 rotate를 구하는데 slicing을 활용하는 경우 O(max(n, m))이 소요된다.

그러면 총 연산량은 O(k * max(n, m))이 소요되는데, 최대값으로 생각하면 $10^{10} / 2$ 이므로, 유의미한 시간해결은 되지 않았다. 

이제 slicing에서 소요되는 시간을 줄이는 것이 가장 좋은 방법이라고 생각했는데, deque 자료형을 사용하는 경우 왼쪽, 오른쪽 pop() 연산이 모두 O(1)이 걸리기 때문에 이방법으로 수정하는 경우 소요시간은 O(k)가 되므로 문제를 바로 해결할 수 있다.

### 코드
```python
from collections import deque

def solution(rc, operations):
    left_col = deque([rc[i][0] for i in range(len(rc))])
    right_col = deque([rc[i][- 1] for i in range(len(rc))])
    remain = deque([deque(rc[i][1:-1]) for i in range(len(rc))])
    
    for op in operations:
        if op == "Rotate":
            remain[0].appendleft(left_col.popleft()) 
            remain[-1].append(right_col.pop())
            left_col.append(remain[-1].popleft())
            right_col.appendleft(remain[0].pop()) 
        else:
            left_col.appendleft(left_col.pop())
            right_col.appendleft(right_col.pop())
            remain.appendleft(remain.pop())

    return [[left_col[i]] + list(remain[i]) + [right_col[i]] for i in range(len(rc))]
```
## 3. 개선점

## 4. 개선사항

## 5. 개선사항 평가
