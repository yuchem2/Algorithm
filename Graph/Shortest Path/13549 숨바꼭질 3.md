tags: `BOJ`, `Shortest Path`
# [BOJ] 13549번 숨바꼭질 3 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.08.29
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 2초  | 512MB  | 81937 | 20748 | 13845 | 24.456% |

### 문제
---
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

### 입력
---
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
### 출력
---
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

### 예제입력1
```
5 17
```
### 예제출력1
```
2
```
## 2. 소스코드

### 알고리즘
이 문제는 모든 정점이 가중치가 0, 1을 가진 경로를 가지고, 100,001개의 정점을 가지고 있는 그래프라고 볼 수 있다. 여기서 주어진 출발점, 도착점에서의 최단 경로를 찾는 문제이다.  
이 문제는 경로간 우선순위가 정해져 있으므로, Dijkstra 혹은 BFS로 문제를 해결할 수 있다. 최단 거리 문제로 구별되어 있기 때문에 먼저 Dijkstra로 문제를 풀었다. 

### 코드
```Python
from queue import PriorityQueue


def problem13549():
    st, ed = map(int, input().split())
    time = [100000] * 100001

    time[st] = 0
    que = PriorityQueue()
    que.put((time[st], st))

    while not que.empty():
        u = que.get()
        if u[1] == ed:
            break
        for w, v in [[0, 2 * u[1]], [1, u[1] + 1], [1, u[1] - 1]]:
            w += u[0]
            if 0 <= v < 100001 and time[v] > w:
                time[v] = w
                que.put((w, v))

    print(time[ed])


problem13549()

```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 40776KB | 388ms | 520B |

## 3. 개선점
해당 문제에서 push, pop에서 O(log n)시간이 걸리기 때문에 비교적 시간이 오래 걸린다. BFS로도 해결 가능한 문제이므로, BFS로 문제를 풀면 push, pop에서 O(1)이 걸리기 떄문에 시간이 단축될 것이다. 

## 4. 개선사항

BFS로 할때는 큐에 넣는 순서를 잘 생각해 문제를 풀어야 한다. 가중치가 낮은 경우부터 큐에 집어넣어 순차저긍로 BFS 순회를 진행하면 최단거리를 구할 수 있다. 

```Python
from collections import deque


# BFS
def problem13549():
    st, ed = map(int, input().split())
    time = [100000] * 100001

    time[st] = 0
    que = deque()
    que.append((time[st], st))

    while que:
        u = que.popleft()
        if u[1] == ed:
            break
        for w, v in [[0, 2 * u[1]], [1, u[1] + 1], [1, u[1] - 1]]:
            w += u[0]
            if 0 <= v < 100001 and time[v] > w:
                time[v] = w
                que.append((w, v))
    print(time[ed])


problem13549()

```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 35272KB | 128ms | 513B |

## 5. 개선사항 평가

앞서 개선점에서 말한 것처럼 push, pop의 시간이 감소되었기에 전체 실행시간이 감소되었다. 자료형도 heap에서 queue가 되었기 떄문에 메모리양도 감소되었다. 
