tags: `BOJ`, `Shortest Path`, `Floyd-Warshall`
# [BOJ] 11404번 플로이드 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.08.30
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초 | 256MB | 59901 | 25217 | 17766  | 41.613% |

### 문제
---
n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.

모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

### 입력
---
첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.

시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.

### 출력
---
n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

### 예제입력1
```
5
14
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
3 5 10
3 1 8
1 4 2
5 1 7
3 4 2
5 2 4
```
### 예제출력1
```
0 2 3 1 4
12 0 15 2 5
8 5 0 1 1
10 7 13 0 3
7 4 10 6 0
```
## 2. 소스코드

### 알고리즘
모든 도시에 대해서 각 도시에서 시작해 다른 도시로 가는 최단 거리를 구하는 문제이다. 이 문제를 Dijkstra로 해결하기 위해서는 정점의 개수만큼 Dijkstra를 반복해서 수행해야 한다. 이렇게 문제를 풀게 되면 시간초과가 발생할 것이다.  
그러므로 다른 알고리즘을 사용할 필요가 있는데, 문제 조건을 보면 정점의 개수는 최대 100개 이므로, 간선을 저장할 때 인접행렬을 사용할 수 있다. 그리고 모든 최소 경로를 구하는 문제이기 떄문에 Floyd-Warshall 알고리즘을 이용해 문제를 해결할 수 있다.  
이 알고리즘은 최악의 경우 O($n^3$)의 시간을 소요한다. 먼저 간선의 정보를 인접행렬로 저장한다. 그 후 모든 정점에 대해 순회를 한다. 이때 순회를 할때 정점은 경유지이다.  
그리고, 이 정점을 경유지로 사용하는 경우에 대한 모든 경로를 검사하며 최소 경로를 찾아서 업데이트한다. 이를 반복해서 문제를 해결하는 것이다.  


### 코드
```Python
import sys


def problem11404():
    n, m = int(sys.stdin.readline()), int(sys.stdin.readline())
    INF = 123456789
    distance = [[INF]*n for _ in range(n)]
    for _ in range(m):
        u, v, w = map(int, sys.stdin.readline().split())
        if distance[u-1][v-1] > w:
            distance[u-1][v-1] = w

    for waypoint in range(n):
        for i in range(n):
            for j in range(n):
                if i != j:
                    distance[i][j] = min(distance[i][j], distance[i][waypoint] + distance[waypoint][j])

    for i in range(n):
        for j in range(n):
            if distance[i][j] == INF:
                sys.stdout.write("0 ")
            else:
                sys.stdout.write(str(distance[i][j])+" ")
        sys.stdout.write("\n")


problem11404()

```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 384ms | 782B |

## 3. 개선점
x
## 4. 개선사항

x

## 5. 개선사항 평가
x
