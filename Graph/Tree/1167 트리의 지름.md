Tags: `BOJ`, `Graph`, `Tree`, `DFS/BFS`
# [BOJ] 1167번 트리의 지름 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.09.11
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 2초 | 256MB | 45939 | 16795 | 12095 | 34.023% |

### 문제
---
트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.

### 입력
---
트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.

먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.

### 출력
---
첫째 줄에 트리의 지름을 출력한다.

### 예제입력1
```
5
1 3 2 -1
2 4 4 -1
3 1 2 4 3 -1
4 2 4 3 3 5 6 -1
5 4 6 -1
```
### 예제출력1
```
11
```
## 2. 소스코드

### 알고리즘
naive하게 코드를 작성한다고 생각하면 임의의 노드에서 최대 정점의 길이를 계산하면 된다. 이를 모든 노드에 대해 수행한다면 답을 구할 수 있다. 그러나 이 경우 n번의 dfs를 수행해야 하므로 시간초과가 발생한다.  
해결법이 떠오르지 않아 Diameter of a Tree에 대해 검색해 해당 정의를 이해함으로써 문제를 풀 수 있었다. https://iq.opengenus.org/diameter-of-tree-using-dfs/ 를 참고해 문제를 풀었다.  

트리 혹은 방향이 없는 그래프에서 응용할 수 있는 방법으로, 임의의 두 노드의 최장 거리를 구할 때 이용할 수 있는 방법이였다. 한 문장으로 적으면 단순히 두번의 dfs를 수행하는 것이다.  
1. 임의의 노드를 루트로 정하고, dfs를 수행해 그 임의의 노드에서 가장 먼 거리에 있는 노드 x를 찾는다.
2. 노드 x에서 다시 dfs를 시행해 노드 x에서 가장 먼 거리에 있는 노드 y를 찾는다.
3. 그러면 x에서 y를 포함하는 길이가 트리의 지름이 된다.

트리의 지름을 정점 u에서 정점 v를 연결하는 경로를 트리의 지름이라고 가정하자. 임의의 정점 x를 정하고, 정점 x에서 가장 먼 정점 y를 찾은 경우는 다음과 같다.
1. x가 u혹은 v인 경우
2. y가 u혹은 v인 경우
3. x, y, u, v가 서로 다른 경우

1, 2 경우에 대해서는 위에서 말한 알고리즘이 정확하게 작동하는 것을 알 수 있다. 3의 경우에 대해서 살펴보면 두 가지 경우가 가능하다.
정점 x와 정점 y를 연결하는 경로가 정점 u와 정점 v를 연결하는 경로와 한 점 이상을 공유하는 경우와 완전히 독립적인 경우이다. 

한점 t를 공유한다고 생각하자. 트리의 지름은 u-v이다. 이렇게 두면 t-y는 t-u 혹은 t-v이다. 왜냐하면 x에서 가장 먼 길이는 y인데, 지름은 u-v임으로, t에서 더 먼 정점까지의 길이는 max(t-u, t-v)이기 때문이다.  

독립인 경우로 보면 x, y 사이에 노드 a가 있고, u, v 사이에 노드 b가 있다고 생각해보자. x-y입장에서 a-y가 a-b-v 또는 a-b-u보다 더 길어야 한다. u-v 입장에서는 b-v가 b-a-x 혹은 b-a-y보다 더 길어야 한다. 
이렇게 되면 a-y가 a-b-v보다 크고, b-v가 b-a-y보다 커야 한다. (a-y) > (a-b) + (b-v) 이고, (b-v) > (b-a) + (a-y) 이므로 모순이 생긴다. 

그래서 3번 경우에는 한점 t를 공유할 수 밖에 없다. 그러므로 1, 2, 3 경우에서 트리의 지름을 구할 수 있다고 할 수 있다. 



### 코드
```Python
import sys
sys.setrecursionlimit(10**6)


def problem1167(i, w):
    visited[i] = 1
    global max_distance, max_node
    if w > max_distance:
        max_distance, max_node = w, i

    for u, c in adj[i]:
        if visited[u] == 0:
            problem1167(u, w+c)


v_num = int(input())
adj = [[] for _ in range(v_num)]
for _ in range(v_num):
    buff = list(map(int, sys.stdin.readline().split()))
    i = 1
    while buff[i] != -1:
        adj[buff[0]-1].append((buff[i]-1, buff[i+1]))
        i += 2
max_distance, max_node = -1, -1
visited = [0]*v_num
problem1167(0, 0)

max_distance = -1
for i in range(v_num):
    visited[i] = 0

problem1167(max_node, 0)
print(max_distance)

```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 67636KB | 540ms | 682B |

## 3. 개선점
x
## 4. 개선사항

x

## 5. 개선사항 평가
x
