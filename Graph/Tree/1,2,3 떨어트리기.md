tags: `Programmers`, `Graph`, `Tree`
# [Programmers] 1,2,3 떨어트리기 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/150364

ID: yuchem2@gmail.com

Date: 2024.11.26

소요시간: 3시

## 1. 문제설명

### 문제
---

춘식이는 트리의 1번 노드에 숫자 1, 2, 3 중 하나씩을 계속해서 떨어트려 트리의 리프 노드1에 숫자를 쌓는 게임을 하려고 합니다.
아래 그림은 게임의 예시를 나타냅니다.

![image](https://github.com/user-attachments/assets/6399d652-f466-4b76-8e57-e55173770fee)


+ 트리의 모든 간선은 부모 노드가 자식 노드를 가리키는 단방향 간선입니다.
+ 모든 부모 노드는 자식 노드와 연결된 간선 중 하나를 길로 설정합니다.
  + 실선 화살표는 길인 간선입니다.
  + 점선 화살표는 길이 아닌 간선입니다.
+ 모든 부모 노드는 자신의 자식 노드 중 가장 번호가 작은 노드를 가리키는 간선을 초기 길로 설정합니다.

[게임의 규칙]은 아래와 같습니다.

+ 1번 노드(루트 노드)에 숫자 1, 2, 3 중 하나를 떨어트립니다.
+ 숫자는 길인 간선을 따라 리프 노드까지 떨어집니다.
+ 숫자가 리프 노드에 도착하면, 숫자가 지나간 각 노드는 현재 길로 연결된 자식 노드 다음으로 번호가 큰 자식 노드를 가리키는 간선을 새로운 길로 설정하고 기존의 길은 끊습니다.
  + 만약 현재 길로 연결된 노드의 번호가 가장 크면, 번호가 가장 작은 노드를 가리키는 간선을 길로 설정합니다.
  + 노드의 간선이 하나라면 계속 하나의 간선을 길로 설정합니다.
+ 원하는 만큼 계속해서 루트 노드에 숫자를 떨어트릴 수 있습니다.
  + 단, 앞서 떨어트린 숫자가 리프 노드까지 떨어진 후에 새로운 숫자를 떨어트려야 합니다.


[게임의 목표]는 각각의 리프 노드에 쌓인 숫자의 합을 target에서 가리키는 값과 같게 만드는 것입니다.
예를 들어, target이 [0, 0, 0, 3, 0, 0, 5, 1, 2, 3]일 경우 아래 표와 같은 의미를 가집니다.

| 노드 번호 | 노드에 쌓인 숫자의 합  |
|-------|---------------|
| 1     | 0             |
| 2     | 0             |
| 3     | 0             |
| 4     | 3             |
| 5     | 0             |
| 6     | 0             |
| 7     | 5             |
| 8     | 1             |
| 9     | 2             |
| 10    | 3             |

target대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해서는 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 됩니다.

아래 두 그림은 순서대로 1, 2번째 숫자 [2, 1]을 떨어트린 뒤의 길 상황을 나타냅니다.

![image](https://github.com/user-attachments/assets/c5e32961-a4af-47b4-8fc8-286d1d56a8ca)

+ 숫자 2는 떨어지면서 1번 노드와 2번 노드를 지나갔습니다.
  + 1번 노드는 3번 노드를 가리키는 간선을 길로 설정합니다.
  + 2번 노드는 5번 노드를 가리키는 간선을 길로 설정합니다.
+ 숫자 1은 떨어지면서 1번 노드, 3번 노드, 6번 노드를 지나갔습니다.
  + 1번 노드는 3번 노드보다 번호가 큰 노드를 가리키는 간선이 없으므로 다시 2번 노드를 가리키는 간선을 길로 설정합니다.
  + 3번 노드는 간선이 하나이므로 계속해서 6번 노드를 가리키는 간선을 길로 설정합니다.
  + 6번 노드는 9번 노드를 가리키는 간선을 길로 설정합니다.

아래 두 그림은 순서대로 3, 4번째 숫자 [2, 2]를 떨어트린 뒤의 길 상황을 나타냅니다.

![image](https://github.com/user-attachments/assets/df29b052-5d07-4d39-afc7-2b41d3df8209)


아래 세 그림은 순서대로 5, 6, 7번째 숫자 [1, 3, 3]을 떨어트린 뒤의 길 상황을 나타냅니다.

![image](https://github.com/user-attachments/assets/9eb4896a-0516-433c-8310-0007a5dc5acd)

각 리프 노드에 쌓인 숫자를 모두 더해 배열로 나타내면 target과 같습니다.

트리의 각 노드들의 연결 관계를 담은 2차원 정수 배열 edges, 각 노드별로 만들어야 하는 숫자의 합을 담은 1차원 정수 배열 target이 매개변수로 주어집니다. 이때, target 대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해 숫자를 떨어트리는 모든 경우 중 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우를 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 만약, target대로 숫자의 합을 만들 수 없는 경우 [-1]을 return 해주세요.

### 제한사항
+ 1 ≤ edges의 길이 ≤ 100
  + edges[i]는 [부모 노드 번호, 자식 노드 번호] 형태로, 단방향으로 연결된 두 노드를 나타냅니다.
    + 1 ≤ 노드 번호 ≤ edges의 길이 + 1
  + 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다.
  + 항상 하나의 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다.
  + 1번 노드는 항상 루트 노드입니다.
+ target의 길이 = edges의 길이 + 1
  + target[i]는 i + 1번 노드에 쌓인 숫자의 합으로 만들어야 하는 수를 나타냅니다.
    + 0 ≤ 리프 노드의 target값 ≤ 100
    + 리프 노드를 제외한 노드의 target값 = 0
  + target의 원소의 합은 1 이상입니다.

### 예제입출력
| edges                                                                     | target                         | result                 |
|---------------------------------------------------------------------------|--------------------------------|------------------------|
| [[2, 4], [1, 2], [6, 8], [1, 3], [5, 7], [2, 5], [3, 6], [6, 10], [6, 9]] | [0, 0, 0, 3, 0, 0, 5, 1, 2, 3] | [1, 1, 2, 2, 2, 3, 3]  |
| [[1, 2], [1, 3]]                                                          | [0, 7, 3]                      | [1, 1, 3, 2, 3]        |
| [[1, 3], [1, 2]]                                                          | [0, 7, 1]                      | [-1]                   |

## 2. 소스코드

### 알고리즘

해당 문제는 먼저 주어진 간선으로부터 tree를 구성해 놓은 후 문제를 푸는 것이 좋아보였다. 다음과 같은 순서로 문제를 풀었다.

1. 간선으로부터 부모, 자식 노드 정보를 받아 각 노드의 자식 노드 정보를 배열로 저장한다.
2. 문제의 조건에 따라 임의의 노드의 자식노드는 작은 노드 번호부터 큰 노드 순으로 순회하며 이동할 수 있는 간선이 생기게 된다. 그러므로 각 노드의 자식 노드들을 오름차순으로 정렬한다. 이때 leaf node가 아니거나 target이 0인 leaf node 정보를 저장한다.
3. 이 정보를 통해 leaf node에 방문하는 순서를 구한다.
4. 방문하는 순서를 구했다면, 방문하는 횟수를 통해서 사전순이 가까운순으로 배열해 주어진 target 배열을 완성할 수 있도록 숫자를 대입시킨다.


1, 2번 과정은 빠르게 코드를 작성할 수 있으니, 3번과 4번이 해당 문제의 핵심이 된다.

1, 2번을 잘 구했으면, 각 시도에 어떤 leaf node에 도착하는 지는 쉽게 구할 수 있다. 여기서 "언제"까지 시도를 하는지가 중요한데 이는 숫자 타일로 만들 수 있는 조합의 범위로 생각해 볼 수 있다.

번호가 1, 2, 3이기 때문에 이 조합으로 만들 수 있는 수의 범위는 [방문 횟수, 방문횟수 * 3] 이다. 만들어야하는 target 값이 이 범위를 "한 번"이라도 만족하면 그 노드는 값을 만들 수 있는 상태가 된다. 여기서 target이 0이 아닌 모든 leaf node가 이 조건을 한 번이라도 만족하게끔 할 때까지 반복해 방문 횟수를 구한다. 
이때 한 노드의 방문횟수가 target의 값보다 많아지면, 1로만 넣어도 만족하지 못하기 때문에 [-1]을 리턴하도록 한다.

4번 과정은 각 노드의 방문한 순서를 통해 문제를 구하면 된다. 3번 과정에서 각 노드에 "몇 번째"로 도착했는지 정보를 얻을 수 있는데, 해당 정보를 통해 값을 대입하면 된다. "사전 순"이 중요하기 때문에 앞쪽 번호일 수록 작은 수가 나오도록 조정하면 된다.

 
### 코드
```python
def solution(edges, target):
	# tree 구성
    tree = [[] for _ in range(len(edges)+1)]
    for p, c in edges:
        tree[p-1].append(c-1)

    count = [0] * len(tree) # 시뮬레이션 시 방문횟수 저장
    check = [False] * len(tree) # 노드가 result를 만족하는 지 확인
    for i in range(len(tree)):
        if tree[i]: # leaf만 확인하면 됨
            tree[i].sort()
            check[i] = True
        elif target[i] == 0:
            check[i] = True
            
    result = [[] for _ in range(len(tree))] # 언제 방문했는지 저장
    leaf_count = check.count(False) # 확인해야 하는 leaf의 수
    cnt = 0 # 총 시뮬레이션 횟수
    while leaf_count > 0:
	    # 현재 방문 가능한 leaf 방문
        cur = 0
        while tree[cur]:
            nxt = tree[cur][count[cur] % len(tree[cur])]
            count[cur] += 1
            cur = nxt
        result[cur].append(cnt)
        cnt += 1
        count[cur] += 1
        if count[cur] <= target[cur] <= count[cur] * 3: # 방문횟수 < reasult < 방문횟수 * 3
            if not check[cur]: # 위 조건을 만족하고, 확인해야 하는 leaf이기 때문에 조건을 만족한다고 판단
                check[cur] = True
                leaf_count -= 1
        elif count[cur] > target[cur]: # result < 방문횟수인 경우 target을 못만들기 때문에 조기 종료
            return [-1]
        
    answer = [0] * cnt
    for i in range(len(target)):
        for j in range(len(result[i])):
            for num in [1, 2, 3]:
                if count[i] - 1 == 0:
                    answer[result[i][j]] = target[i] # 방문횟수가 1번남은 경우 target[i]만큼 채워야 하기 때문
                    break
                elif count[i] - 1 <= target[i] - num <= (count[i] - 1) * 3: # 1번 이상 남은 경우 주어진 범위를 만족하는 num을 answer 에 삽입
                    target[i] -= num
                    answer[result[i][j]] = num
                    count[i] -= 1
                    break
    return answer
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
