tags: `Programmers`, `Graph`, `Tree`, `Binary Tree`
# [Programmers] 표현 가능한 이진트리 (PYTHON)
Programmers 코딩테스트 연습: 

ID: yuchem2@gmail.com

Date: 2024.11.19

소요시간: 1시간30분

## 1. 문제설명

### 문제
---
당신은 이진트리를 수로 표현하는 것을 좋아합니다.

이진트리를 수로 표현하는 방법은 다음과 같습니다.

1. 이진수를 저장할 빈 문자열을 생성합니다.
2. 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다.
3. 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다.
4. 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다.
5. 문자열에 저장된 이진수를 십진수로 변환합니다.

이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.

다음은 이진트리를 수로 표현하는 예시입니다.

주어진 이진트리는 다음과 같습니다.

![image](https://github.com/user-attachments/assets/a95d9dc2-0d93-46a1-9427-a3777dbcf8da)

주어진 이진트리에 더미노드를 추가하여 포화 이진트리로 만들면 다음과 같습니다. 더미 노드는 점선으로 표시하였고, 노드 안의 수는 살펴보는 순서를 의미합니다.

![image](https://github.com/user-attachments/assets/704513a0-20f4-4b85-93fb-9561195fe398)

노드들을 왼쪽에 있는 순서대로 살펴보며 0과 1을 생성한 문자열에 추가하면 "0111010"이 됩니다. 이 이진수를 십진수로 변환하면 58입니다.

당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다.

이진트리로 만들고 싶은 수를 담은 1차원 정수 배열 numbers가 주어집니다. numbers에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한사항
+ 1 ≤ numbers의 길이 ≤ 10,000
  + 1 ≤ numbers의 원소 ≤ 1015

### 예제입출력
| numbers       | result     |
|---------------|------------|
| [7, 42, 5]    | [1, 1, 0]  |
| [63, 111, 95] | [1, 1, 0]  |

## 2. 소스코드

### 알고리즘
이 문제는 다음과 같은 과정을 통해 접근하였다.

1. 먼저 입력된 10진수 수를 2진수로 변환한다.
2. 포화 이진트리의 노드 수는 n이 높이라고 하면, $2^n-1$이다. 변환된 2진수의 길이가 해당 값을 만족할때까지 앞에 0으로 채운다.
3. 1, 2과정을 통해 얻은 문자열을 순회하며 더미 노드가 아닌 노드끼리 연결되어 있는지 확인한다.

1, 2과정은 단순한 수학 계산으로 문제를 해결할 수 있다. 3과정이 문제 풀이의 핵심이 된다. 

완성된 문자열을 차례대로 순회하면서 루트노드가 아닌 노드 중 1이 등장하는 경우 루트부터 시작해 해당 노드까지 간선을 통해 순회한다. 이때 만약 중간에 0이 등장하면, 해당 수는 이진트리로 표현이 불가능하다. 

### 코드
```python
import math

def search(target, goal):
    st, end = 0, len(target)
    while st < end:
        mid = (end + st) // 2
        if target[mid] == "0":
            return 0
        if mid > goal:
            end = mid
        elif mid < goal:
            st = mid + 1
        else: 
            return 1
    
def solution(numbers):
    answer = []

    for number in numbers:
        if number == 0:
            answer.append(0)
            continue
        binary = str(bin(number))[2:]
        n = math.ceil(math.log2(len(binary)+1))
        while len(binary) < 2 ** n - 1:
            binary = "0" + binary
        for i in range(len(binary)):
            if binary[i] == "1" and search(binary, i) == 0:
                answer.append(0)
                break
        else:
            answer.append(1)
    
    return answer
```
## 3. 개선점
오랜만에 트리 문제를 풀어 포화 노드의 노드의 수에 대한 이해가 부족해 문제를 해결하는 데 오래걸렸다. 이진 탐색을 항상 머리속에 생각하고 있어야 겠다..
## 4. 개선사항
x
## 5. 개선사항 평가
x
