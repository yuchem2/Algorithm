tags: `BOJ`, `Divide-and-Conquer`
# [BOJ] 2630번 색종이 만들 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.05.20
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
|  1초   | 128MB  | 35147 | 24215 | 18828 | 69.073% |

### 문제
---
아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.

<div align="center">
  <img src="https://github.com/yuchem2/Algorithm/assets/101711808/e35fb5f9-3c81-44bf-a6a9-380815790d82" width="200">
</div>

전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.

전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 <그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.

위와 같은 규칙에 따라 잘랐을 때 <그림 3>은 <그림 1>의 종이를 처음 나눈 후의 상태를, <그림 4>는 두 번째 나눈 후의 상태를, <그림 5>는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.

<div align="center">
  <img src="https://github.com/yuchem2/Algorithm/assets/101711808/f3eb72c5-f0ab-434a-85f6-4a8db2bf25b2" width="400">
</div>

입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.

### 입력
---
첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.
### 출력
---
첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.
### 예제입력1
```
8
1 1 0 0 0 0 1 1
1 1 0 0 0 0 1 1
0 0 0 0 1 1 0 0
0 0 0 0 1 1 0 0
1 0 0 0 1 1 1 1
0 1 0 0 1 1 1 1
0 0 1 1 1 1 1 1
0 0 1 1 1 1 1 1
```
### 예제출력1
```
9
7
```
## 2. 소스코드

### 알고리즘

해당 문제는 주어진 정사각형을 4개로 분할해 문제를 해결하는 방식이다.  
그런데 분할 종료 조건이 현재 정사각형에 있는 원소가 다 같은 경우이다. 단순히 이를 수행한다면, 분할 종료 조건을 검사하는데 O(n^2)이 걸리게 된다.  
분할 종료 조건의 시간복잡도를 O(1)로 만들기 위해 2차원 누적합 방식을 이용하였다.  


### 코드
```Python
import sys
sys.setrecursionlimit(10**6)

def divide(a, l1, l2, r1, r2):
    global result
    iff = a[r1-1][r2-1] - a[l1-1][r2-1] - a[r1-1][l2-1] + a[l1-1][l2-1]
    if iff == (r2-l2)*(r1-l1):
        result[1] += 1
    elif iff == 0:
        result[0] += 1
    else:
        m1 = (l1+r1)//2
        m2 = (l2+r2)//2
        divide(a, l1, l2, m1, m2)
        divide(a, l1, m2, m1, r2)
        divide(a, m1, l2, r1, m2)
        divide(a, m1, m2, r1, r2)


def problem2630():
    num = int(input())

    array = [0]*(num+1)

    array[0] = [0]*(num+1)
    for i in range(1, num+1):
        array[i] = list(map(int, sys.stdin.readline().split()))
        array[i].insert(0, 0)
    for i in range(1, num+1):
        for j in range(1, num+1):
            array[i][j] = array[i][j] + array[i][j-1] + array[i-1][j] - array[i-1][j-1]

    global result
    result = [0, 0]

    divide(array, 1, 1, num+1, num+1)
    print(result[0])
    print(result[1])

problem2630()
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 52ms | 959B |

## 3. 개선점
x
## 4. 개선사항

x

## 5. 개선사항 평가
x
