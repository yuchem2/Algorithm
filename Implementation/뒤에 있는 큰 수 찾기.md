tags: `Programmers`, `Implementation`
# [Programmers] 뒤에 있는 큰 수 찾기 (PYTHON)
Programmers 코딩테스트 연습: 

ID: yuchem2@gmail.com

Date: 2024.11.12

소요시간: 30분

## 1. 문제설명

### 문제
---
정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다.
정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.

### 제한사항
+ 4 ≤ numbers의 길이 ≤ 1,000,000
	+ 1 ≤ numbers[i] ≤ 1,000,000
### 예제입출력
| numbers            | result                |
|--------------------|-----------------------|
| [2, 3, 3, 5]       | [3, 5, 5, -1]         |
| [9, 1, 5, 3, 6, 2] | [-1, 5, 6, 6, -1, -1] |

## 2. 소스코드

### 알고리즘
처음에 문제를 단순 순회방식으로 해결하고자 하였다. 그랬을 때 답은 해결할 수 있었지만, 시간초과가 발생하였다. O($n^2$) 보다 적은 방법을 찾아야 했다.

뒷 큰수는 현재 자기자신보다 큰 첫 번째 수이다. 만약 [95, 90, 2, 3, 7, 9, 100] 이라는 배열이 있다고 가정하면, 90의 뒷 큰수는 100이 된다. 

단순한 방식의 탐색에서는 90 뒤의 수를 모두 순회하다가 자신보다 큰 수가 등장할 때까지 순회를 진행한다. 

그 후에도 95의 뒷 큰수는 100인데, 단순하게 순회를 반복하면, 95에서도 90부터 100까지 순회를 반복해야 한다. 

이러한 과정의 순회를 줄이는 것이 핵심이다. 순회를 살펴보면, 사실 95는 90과 90의 뒷 큰수인 100만 확인하면 된다. 하지만 90의 경우 자신의 뒷 수와 2의 뒷 큰수를 확인해도, 자기 자신보다 작기 때문에 결국 자신보다 큰 수인 100을 찾기 위해 순회를 지속해야 한다.

90의 순회에서 특정 작업을 통해 95의 순회를 줄인다면 문제를 쉽게 해결할 수 있다고 생각하였다.

그래서 stack을 이용하고자 했다. stack의 위에는 항상 현재 값보다 큰 값이 있도록 한다. 만약 그렇지 않은 경우 stack의 차례대로 계속 비운다. 

stack의 맨 위값을 항상 큰 뒷수로 파악하고, 이후 자기 자신을 다시 stack에 넣는다. 이렇게 하면, 항상 모든 값을 순회할 수 있고, 순회 과정도 감소시킬 수 있다.

### 코드
```python
def solution(numbers):
    answer = [-1] * len(numbers)
    stack = [numbers[-1]]
    for i in range(len(numbers)-2, -1, -1):
        while stack and numbers[i] >= stack[-1]:
            stack.pop()
        if stack:
            answer[i] = stack[-1]
        stack.append(numbers[i])
    return answer
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
