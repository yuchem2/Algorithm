tags: `BOJ`, `Implementation`
# [BOJ] 24416번 알고리즘 수업 - 피보나치 수 1 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.03.29

## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초   |  512MB | 11257  | 6539 | 5837  | 59.289%  |

### 문제
---
오늘도 서준이는 동적 프로그래밍 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

오늘은 n의 피보나치 수를 재귀호출과 동적 프로그래밍으로 구하는 알고리즘을 배웠다. 재귀호출에 비해 동적 프로그래밍이 얼마나 빠른지 확인해 보자. 아래 의사 코드를 이용하여 n의 피보나치 수를 구할 경우 코드1 코드2 실행 횟수를 출력하자.

피보나치 수 재귀호출 의사 코드는 다음과 같다.
```
fib(n) {
    if (n = 1 or n = 2)
    then return 1;  # 코드1
    else return (fib(n - 1) + fib(n - 2));
}
```
피보나치 수 동적 프로그래밍 의사 코드는 다음과 같다.
```
fibonacci(n) {
    f[1] <- f[2] <- 1;
    for i <- 3 to n
        f[i] <- f[i - 1] + f[i - 2];  # 코드2
    return f[n];
}
```
### 입력
---
첫째 줄에 n(5 ≤ n ≤ 40)이 주어진다.

### 출력
---
코드1 코드2 실행 횟수를 한 줄에 출력한다.


### 예제 입력1
```
5
```
### 예제 출력1
```
5 3
```

## 2. 소스코드
```Python
def fib1(x):
    if x == 1 or x == 2:
        return 1        # code 1
    else:
        return fib1(x-1) + fib1(x-2)

def fib2(x):
    f = [0] * x
    f[0], f[1] = 1, 1
    cnt = 0
    for i in range(2, x):
        # f[i] = f[i-1] + f[i-2]  # code 2
        cnt += 1
    return cnt

n = int(input())
a = fib1(n)
b = fib2(n)
print(a, b)
```

Python: 13%에서 시간초과

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 시간초과 | | | 336B |

PyPy3: 정상적으로 정답 산출

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 130012KB | 1896ms | 336B |

## 3. 개선점
Python이 다른 언어보다 느리기 때문에 시간 초과. 재귀 부분을 단순 시뮬레이션이 아닌 수학적 접근이 필요하다

코드를 통해 봤을 때 코드 1의 반복 횟수는 결국 n번째 피보나치 수와 동일하다. 그러므로 1번의 피보나치 재귀 호출을 시뮬레이션 돌리는 것이 아니라 결과를 출력하면 된다.  

## 4. 개선사항
```Python
def fib(x):
    f = [0] * x
    f[0], f[1] = 1, 1
    cnt = 0
    for i in range(2, x):
        f[i] = f[i-1] + f[i-2]  # code 2
        cnt += 1
    print(f[n-1], cnt)

n = int(input())
fib(n)
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 40ms | 193B |

## 5. 개선사항 평가
개선 사항으로 인해 시간 내 완벽하게 풀이할 수 있었다. 또한 PyPy3의 결과를 보면 1896ms가 걸리며 메모리 공간도 130012KB 만큼 사용한다. 

하지만 개선사항 코드의 경우 40ms가 소요되며 메모리 공간이 31256KB만을 사용한다. 

이를 통해 동적 계획법이 재귀보다 월등한 성능을 가지고 있음을 알 수 있다. (재귀를 동적 계획법으로 구현 가능한 경우에)
