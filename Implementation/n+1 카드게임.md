tags: `Programmers`, `Implementation`
# [Programmers] n+1카드게임 (PYTHON)
Programmers 코딩테스트 연습: 

ID: yuchem2@gmail.com

Date: 2024.10.09

소요시간: 4시간

## 1. 문제설명

### 문제
---

당신은 1~n 사이의 수가 적힌 카드가 하나씩 있는 카드 뭉치와 동전 coin개를 이용한 게임을 하려고 합니다. 카드 뭉치에서 카드를 뽑는 순서가 정해져 있으며, 게임은 다음과 같이 진행합니다.

1. 처음에 카드 뭉치에서 카드 n/3장을 뽑아 모두 가집니다. (n은 6의 배수입니다.) 당신은 카드와 교환 가능한 동전 coin개를 가지고 있습니다.
2. 게임은 1라운드부터 시작되며, 각 라운드가 시작할 때 카드를 두 장 뽑습니다. 카드 뭉치에 남은 카드가 없다면 게임을 종료합니다. 뽑은 카드는 카드 한 장당 동전 하나를 소모해 가지거나, 동전을 소모하지 않고 버릴 수 있습니다.
카드에 적힌 수의 합이 n+1이 되도록 카드 두 장을 내고 다음 라운드로 진행할 수 있습니다. 만약 카드 두 장을 낼 수 없다면 게임을 종료합니다.
예를 들어 n = 12, coin = 4이고 [3, 6, 7, 2, 1, 10, 5, 9, 8, 12, 11, 4] 순서대로 카드를 뽑도록 카드 뭉치가 섞여 있습니다.

처음에 3, 6, 7, 2 카드 4장(= n/3)과 동전 4개(= coin)를 가지고 시작합니다. 다음 라운드로 진행하기 위해 내야 할 카드 두 장에 적힌 수의 합은 13(= n+1)입니다. 다음과 같은 방법으로 최대 5라운드까지 도달할 수 있습니다.

1. 1라운드에서 뽑은 카드 1, 10을 동전 두 개를 소모해서 모두 가집니다. 카드 3, 10을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2, 6, 7이고 동전이 2개 남습니다.
2. 2라운드에서 뽑은 카드 5, 9를 동전을 소모하지 않고 모두 버립니다. 카드 6, 7을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2고 동전이 2개 남습니다.
3. 3라운드에서 뽑은 카드 8, 12 중 동전 한 개를 소모해서 카드 12를 가집니다. 카드 1, 12을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 2이고 동전이 1개 남습니다.
4. 4라운드에서 뽑은 카드 11, 4 중 동전 한 개를 소모해서 카드 11을 가집니다. 카드 2, 11을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드와 동전은 없습니다.
5. 5라운드에서 카드 뭉치에 남은 카드가 없으므로 게임을 종료합니다.
처음에 가진 동전수를 나타내는 정수 coin과 카드를 뽑는 순서대로 카드에 적힌 수를 담은 1차원 정수 배열 cards가 매개변수로 주어질 때, 게임에서 도달 가능한 최대 라운드의 수를 return 하도록 solution 함수를 완성해 주세요.

### 제한사항

+ 0 ≤ coin ≤ n
+ 6 ≤ cards의 길이 = n < 1,000
  + cards[i]는 i+1번째로 뽑는 카드에 적힌 수를 나타냅니다.
  + 1 ≤ cards[i] ≤ n
  + cards의 원소는 중복되지 않습니다.
+ n은 6의 배수입니다.

### 예제입출력
| coin |	cards |	result |
| :--: | :--: | :--: |
|4|	[3, 6, 7, 2, 1, 10, 5, 9, 8, 12, 11, 4]|	5|
|3|	[1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 11, 12]|	2|
|2	|[5, 8, 1, 2, 9, 4, 12, 11, 3, 10, 6, 7]	|4|
|10|	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]|	1|

## 2. 소스코드

### 알고리즘
해당 문제를 단순히 시뮬레이션을 통해 문제를 해결하고자 했었다. 그 결과 제출의 50점만 받고, 나머지 반 케이스에서 모두 틀리는 결과가 나왔다.
해당 결과를 통해 greedy하게 아니라 비용계산을 잘 해서 문제를 해결해야 된다고 생각했다.

그래서 카드 번호 k를 기준으로 k가 등장하는 라운드를 r 배열로, 그 카드를 얻는 데 드는 비용을 cost 배열로 만들어 저장했다.
그 후 이 문제에서는 턴을 진행하기 위해서는 항상 총 카드 수 + 1이 되는 두 수의 조합을 내야 한다. 그 수는 정확하게 전체 카드의 반이 된다.
이 특징을 이용해 최대 카드 번호 / 2까지의 조합에 대해 등장 라운드, 비용을 계산한다.

이때 등장 라운드는 두 카드 중 늦게 등장하는 라운드를 선택하도록 저장하고, 비용은 두 카드의 cost값을 더한 값으로 저장한다.
이를 통해 기존 r 배열과, cost 배열의 길이를 반으로 줄이면서 한번의 각 조합이 언제 완성되고, 얼마만큼의 비용이 드는 지를 알 수 있는 배열이 만들어진다.
이를 통해 rounds라는 2차원 배열을 구성하였는데, 각 라운드에서 0, 1, 2 비용을 지불해서 얻을 수 있는 조합의 수를 배열로 저장한 값이다.

이 배열을 통해 각 라운드에서 비용을 지불해서 얻을 수 있는 조합의 수를 알 수 있다.
해당 배열을 통해 각 라운드를 진행하면서, 다음 라운드를 진행할 때 현재 만들 수 있는 조합 중 제일 작은 비용이 드는 조합의 수를 제출하면서 반복을 수행하고, 
비용을 지불하고 낼 수 있는 조합이 없을 때까지 반복하면, 최대 라운드 수를 알 수 있었다.

이렇듯 여러 선택지가 있는 경우 greedy하게 푸는 것보단 비용과 선택을 잘 할 수 있도록 사전 작업을 하는 것이 중요한 것 같다.

### 코드
```python
def solution(coin, cards):
    answer = 0
    
    r = cards.copy()
    cost = cards.copy()
    init_cards_num = len(cards) // 3
    for i in range(len(cards)):
        if i < init_cards_num:
            r[cards[i]-1] = 1
            cost[cards[i]-1] = 0
        else:
            r[cards[i]-1] = 1 + (i - init_cards_num) // 2
            cost[cards[i]-1] = 1
            
    
    for i in range(len(cards)//2):
        j = len(cards)-i-1
        r[i] = max(r[j], r[i])
        cost[i] = cost[j] + cost[i]
        r[j], cost[j] = 0, 0
            
    rounds = [[0, 0, 0] for _ in range((len(cards) - init_cards_num) // 2)]
    for i in range(len(cards)//2):
        rounds[r[i]-1][cost[i]] += 1
    
    temp = [0, 0, 0]
    while answer < len(rounds):
        for i in range(3):
            temp[i] += rounds[answer][i]
        if sum(temp) < 0 :
            break
        check = 0
        for i in range(3):
            if temp[i] > 0 and coin >= i:
                answer += 1
                coin -= i
                temp[i] -= 1
                break
            else:
                check += 1
        if check == 3:
            break
    return answer + 1
```
## 3. 개선점
이번 문제는 풀면서 시간이 너무 많이 소요되었는데, 풀이 시간을 줄이기 위해 노력이 필요할 것 같다. 
문제를 풀기 전에 문제에서 요구하는 핵심이 무엇인지 잘 파악하는 것이 중요한 것 같다.

## 4. 개선사항
x
## 5. 개선사항 평가
x
