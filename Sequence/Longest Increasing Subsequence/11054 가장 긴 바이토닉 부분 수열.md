tags: `BOJ`, `LIS`
# [BOJ] 11054번 가장 긴 바이토닉 부분 수열 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초   | 256 MB | 44904  | 22918 | 17902  | 50.585% |

### 문제
---
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.
### 입력
---
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)
### 출력
---
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.
### 예제입력1
```
10
1 5 2 1 4 3 4 5 2 1
```
### 예제출력1
```
7
```
## 2. 소스코드

### 알고리즘
이 문제는 어느 숫자를 기준으로 그 숫자 이전에는 오름차순이고, 이후에는 내림차순인 부분수열을 찾는 문제이다.  
이때 오름차순이기만하거나 내림차순이기만 해도 바이토닉 부분 수열이다.  
이를 이용해 생각해보면, 앞서 가장 긴 증가하는 부분 수열을 두 번 구하면 된다.  
두번 구한다는 의미는 앞 부분부터 시작하는 증가하는 부분 수열을 구하고, 뒤 부분부터 시작하는 증가하는 부분 수열을 구하면 되는 것이다.  
그리고 구해진 두 값을 합친 길이에서 -1을 하면 우리가 구하고자 하는 가장 긴 바이토닉 부분 수열의 길이를 구할 수 있다.  
이때 -1을 하는 이유는 기준이 되는 숫자가 중복되기 때문이다.  

### 코드
```Python
num = int(input())
array = list(map(int, input().split()))

l_dp = [1] * num
r_dp = [1] * num
dp = [0] * num

for i in range(num):
    for j in range(i):
        if array[i] > array[j]:
            l_dp[i] = max(l_dp[i], l_dp[j]+1)

for i in range(num-1, -1, -1):
    for j in range(i+1, num):
        if array[i] > array[j]:
            r_dp[i] = max(r_dp[i], r_dp[j]+1)
for i in range(num):
    dp[i] = max(r_dp[i] + l_dp[i], dp[i])

print(max(dp)-1)
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 272 ms | 452B |

## 3. 개선점

11053번과 동일한 개선점을 추가한다면 실행시간을 의미있게 줄일 수 있을 것이다.  

## 4. 개선사항
```Python
num = int(input())
array = list(map(int, input().split()))
l_dp = [1] * num
r_dp = [1] * num
l_d = [[0], [0]]
r_d = [[0], [0]]
dp = [0] * num


def find(x, i, dp, d):
    if x[i] > d[1][-1]:
        dp[i] = d[0][-1]+1
        d[0].append(dp[i])
        d[1].append(x[i])
    elif array[i] == d[1][-1]:
        dp[i] = d[0][-1]
    else:
        j = 0
        while j < len(d[1]):
            if x[i] > d[1][j]:
                j += 1
            elif x[i] == d[1][j]:
                dp[i] = d[0][j]
                break
            else:
                d[1][j] = x[i]
                dp[i] = d[0][j]
                break

for i in range(0, num):
    find(array, i, l_dp, l_d)
for i in range(num-1, -1, -1):
    find(array, i, r_dp, r_d)
for i in range(num):
    dp[i] = max(r_dp[i] + l_dp[i], dp[i])

print(max(dp)-1)
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256 KB | 60ms | 821B |

## 5. 개선사항 평가

11053번보다 더 의미있는 시간 감소를 보였다. 시간이 매우 단축되었다. 
