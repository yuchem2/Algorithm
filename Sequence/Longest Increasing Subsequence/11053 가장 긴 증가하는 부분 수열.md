tags: `BOJ`, `LIS`
# [BOJ] 11053번 가장 긴 증가하는 부분 수열 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.05.12
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초  | 256 MB  | 136356  | 53939 | 35570 | 37.520% |

### 문제
---
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.
### 입력
---
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)
### 출력
---
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.
### 예제입력1
```
6
10 20 10 30 20 50
```
### 예제출력1
```
4
```
## 2. 소스코드

### 알고리즘
처음 문제를 보았을 때 혼동이 있었으나 천천히 하나의 원소의 관점으로 살펴보면 풀 수 있었다.  
차근 차근 i=0 일때 부터 고민한다. 예제 입력의 경우라고 생각하고 문제를 풀면 다음과 같다.  
1. i=0 이면 처음 값이므로 최장 길이가 1이다.
2. i=1 이면 20은 이전 값보다 크기 때문에 길이가 2가 된다.
3. i=2 이면 이전 값들 중에 10보다 작은 값이 없기 때문에 1이 된다.
4. i=3 이면 이전 값들 중 30보다 작은 값이 10, 20이 있기 때문에 길이가 2+1이 된다.
5. i=4 이면 이전 값들 중 20보다 작은 값이 10 하나이기 때문에 길이가 1+1이 된다.
6. i=5 이면 이전 값들 중 50보다 작은 값이 10, 20, 30이 있기 때문에 길이가 3+1이 된다.  

즉 답은 4가 된다. 이와 같은 방법을 통해 각 첨자에서 이전 값들 중 작은 값의 최대 길이+1을 저장함으로써 알고리즘을 수행한다.  
이전 값들을 전부 살펴보아야 하기 때문에 O(n^2)이 걸렸다.  

### 코드
```Python
num = int(input())
inArray = list(map(int, input().split()))

inArray.insert(0, 0)
dp = [1] * (num+1)

for i in range(1, num+1):
    for j in range(1, i):
        if inArray[i] > inArray[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp[1:]))
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 156 ms | 250B |

## 3. 개선점
문제를 풀고 나니 이전 값들을 전부 살펴보아야 하는가? 라는 고민이 들었다..  
앞서 방법은 dp 배열만을 이용해 문제를 풀었다. 하지만 각 길이의 최고 값을 저장하고 있는 배열을 만든다면 탐색 방법이 단축될 것이라고 생각했다.  

먼저 d 배열을 만든다. 그리고 [[0], [0]] 형태로 초기화 한다.  
그리고 먼저 주어진 수열의 인덱스를 i라고 할때 i번째 원소가 d[1][-1] 보다 크다면 d[0]에 d[0][-1] 값을 새롭게 추가한다. 또한, d[1]에 i번째 원소 값을 추가한다.  
이렇게 한다면 현재 최고 길이를 저장하게 되고, 그에 해당하는 최고 길이 부분 수열의 마지막 원소 값을 저장할 수 있다.  

이 방법을 사용하는 경우에 i번째 원소가 d[1][-1]보다 작은 경우에 추가적인 처리가 필요하게 되었다.  
d[1][-1]보다 작은 경우 d[1] 배열에 대한 탐색이 필요하다.  
d[1][0]부터 시작해서 탐색을 진행한다. 이때 탐색은 d[1][j] 값이 같거나 i번째 원소보다 작을 때까지 진행한다.  
같은 경우는 단순히 탐색을 종료하고, 작은 경우에는 해당 j부분의 값을 새롭게 i번째 원소값으로 최신화 시킨다. 

## 4. 개선사항
```Python
num = int(input())
inArray = list(map(int, input().split()))

inArray.insert(0, 0)
d = [[0], [0]]
for i in range(1, num+1):
    if inArray[i] > d[1][-1]:
        d[0].append(d[0][-1]+1)
        d[1].append(inArray[i])
    elif inArray[i] < d[1][-1]:
        j = 0
        while j < len(d[1]):
            if inArray[i] > d[1][j]:
                j += 1
            elif inArray[i] == d[1][j]:
                break
            else:
                d[1][j] = inArray[i]
                break

print(d[0][-1])
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 48ms | 508B |

## 5. 개선사항 평가

해당 방법으로 탐색시간이 줄게 되었다. 이로 인해 실행시간이 1/3가량 감소하였다. 
