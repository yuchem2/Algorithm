tags: `Programmers`, `Greedy`
# [Programmers] 디펜스 게임 (PYTHON)
Programmers 코딩테스트 연습: 

ID: yuchem2@gmail.com

Date: 2024.12.10

소요시간: 1시간

## 1. 문제설명

### 문제
---
준호는 요즘 디펜스 게임에 푹 빠져 있습니다. 디펜스 게임은 준호가 보유한 병사 n명으로 연속되는 적의 공격을 순서대로 막는 게임입니다. 디펜스 게임은 다음과 같은 규칙으로 진행됩니다.

준호는 처음에 병사 n명을 가지고 있습니다.
매 라운드마다 enemy[i]마리의 적이 등장합니다.
남은 병사 중 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있습니다.
예를 들어 남은 병사가 7명이고, 적의 수가 2마리인 경우, 현재 라운드를 막으면 7 - 2 = 5명의 병사가 남습니다.
남은 병사의 수보다 현재 라운드의 적의 수가 더 많으면 게임이 종료됩니다.
게임에는 무적권이라는 스킬이 있으며, 무적권을 사용하면 병사의 소모없이 한 라운드의 공격을 막을 수 있습니다.
무적권은 최대 k번 사용할 수 있습니다.
준호는 무적권을 적절한 시기에 사용하여 최대한 많은 라운드를 진행하고 싶습니다.

준호가 처음 가지고 있는 병사의 수 n, 사용 가능한 무적권의 횟수 k, 매 라운드마다 공격해오는 적의 수가 순서대로 담긴 정수 배열 enemy가 매개변수로 주어집니다. 준호가 몇 라운드까지 막을 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
+ 1 ≤ n ≤ 1,000,000,000
+ 1 ≤ k ≤ 500,000
+ 1 ≤ enemy의 길이 ≤ 1,000,000
+ 1 ≤ enemy[i] ≤ 1,000,000
+ enemy[i]에는 i + 1 라운드에서 공격해오는 적의 수가 담겨있습니다.
+ 모든 라운드를 막을 수 있는 경우에는 enemy[i]의 길이를 return 해주세요.

### 예제입출력

| n                | k         | enemy                 | result  |
|------------------|-----------|-----------------------|---------|
| 7                | 3         | [4, 2, 4, 5, 3, 3, 1] | 5       |
| 2                | 4         | [3, 3, 3, 3]          | 4       |


## 2. 소스코드

### 알고리즘
처음에는 dp접근법을 통해 문제를 해결하고자 하였다. 하지만 문제의 경우 제한사항의 크기가 매우 커 dp 기법으로도 python에서 시간초과가 발생하였다.

그래서 다른 접근법이 필요했는데, heap queue 기법을 통해 문제를 접근하였다. 

k 라운드까지는 무조건 시행가능하므로, heap의 길이가 k가 될때까지 heap에 단순히 각 라운드의 적의 수를 추가하다 k가 넘는 경우부터 pop을 해주면, heap queue의 특징상 가장 작은 값이 나오므로, 가장 큰 적의 수에서 무적권을 사용하는 것처럼 문제를 해결할 수 있다.
### 코드
```python
import heapq

def solution(n, k, enemy):    
    queue = []
    for i, e in enumerate(enemy):
        heapq.heappush(queue, e)
        if len(queue) > k:
            n -= heapq.heappop(queue)
        if n < 0:
            return i
        
    return len(enemy)
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
