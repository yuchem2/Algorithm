tags: `BOJ`, `Prefix Sum`, `Tww-pointer`
# [BOJ] 1806번 부분합 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.08.31
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 0.5초 | 128B | 81128 | 22248 | 15635 | 25.706% |

### 문제
---
10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.

### 입력
---
첫째 줄에 N (10 ≤ N < 100,000)과 S (0 < S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.

### 출력
---
첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.

### 예제입력1
```
10 15
5 1 3 5 10 7 4 9 2 8
```
### 예제출력1
```
2
```
## 2. 소스코드

### 알고리즘
두 포인터 l,r을 인덱스 0번부터 시작해 현재 누적합이 S보다 크면, l을 증가시키고, S보다 작으면 r을 증가 시킨다. 이를 l, r이 n보다 작을 때까지 반복하며, 만약 r이 n-1와 같으면 반복을 조기 종료한다.

### 코드
```Python
def problem1806():
    n, s = map(int, input().split())
    array = list(map(int, input().split()))
    l, r = 0, 0
    length = n + 1
    cumulative = array[l]
    while l < n and r < n:
        if cumulative >= s:
            if length > r - l + 1:
                length = r - l + 1
            cumulative -= array[l]
            l += 1
        elif r == n-1:
            break
        else:
            r += 1
            cumulative += array[r]

    print(length if length != n + 1 else 0)


problem1806()

```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 42340KB | 96ms | 510B |

## 3. 개선점
x
## 4. 개선사항

x
## 5. 개선사항 평가
x
