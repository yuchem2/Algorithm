tags: `BOJ`, `Prefix Sum`
# [BOJ] 16139번 인간-컴퓨터 상호작용(PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.05.17
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
|  1초  | 256 MB | 14775 | 3904 | 3147 | 28.721% |

### 문제
---
승재는 인간-컴퓨터 상호작용에서 생체공학 설계를 공부하다가 키보드 자판이 실용적인지 궁금해졌다. 이를 알아보기 위해 승재는 다음과 같은 생각을 했다. 

'문자열에서 특정 알파벳이 몇 번 나타나는지 알아봐서 자주 나타나는 알파벳이 중지나 검지 위치에 오는 알파벳인지 확인하면 실용적인지 확인할 수 있을 것이다.'

승재를 도와 특정 문자열 
$S$, 특정 알파벳 
$\alpha$와 문자열의 구간 
$[l,r]$이 주어지면 
$S$의 
$l$번째 문자부터 
$r$번째 문자 사이에 
$\alpha$가 몇 번 나타나는지 구하는 프로그램을 작성하여라. 승재는 문자열의 문자는 
$0$번째부터 세며, 
$l$번째와 
$r$번째 문자를 포함해서 생각한다. 주의할 점은 승재는 호기심이 많기에 (통계적으로 크게 무의미하지만) 같은 문자열을 두고 질문을 
$q$번 할 것이다.
### 입력
---
첫 줄에 문자열 
$S$가 주어진다. 문자열의 길이는 
$200,000$자 이하이며 알파벳 소문자로만 구성되었다. 두 번째 줄에는 질문의 수 
$q$가 주어지며, 문제의 수는 
$1\leq q\leq 200,000$을 만족한다. 세 번째 줄부터 
$(q+2)$번째 줄에는 질문이 주어진다. 각 질문은 알파벳 소문자 
$\alpha_i$와 
$0\leq l_i\leq r_i<|S|$를 만족하는 정수 
$l_i,r_i$가 공백으로 구분되어 주어진다.
### 출력
---
각 질문마다 줄을 구분해 순서대로 답변한다. 
$i$번째 줄에 
$S$의 
$l_i$번째 문자부터 
$r_i$번째 문자 사이에 
$\alpha_i$가 나타나는 횟수를 출력한다.

### 서브태스크1 (50점)
문자열의 길이는 
$2,000$자 이하, 질문의 수는 
$2,000$개 이하이다.
### 서브태스크2 (50점)
추가 제한 조건이 없다.
### 예제입력1
```
seungjaehwang
4
a 0 5
a 0 6
a 6 10
a 7 10
```
### 예제출력1
```
0
1
2
1
```
## 2. 소스코드

### 알고리즘

누적합을 이용해 문제를 풀이하였다. 보통 누적합 문제는 원소가 수의 형태이기 때문에 단순히 1차원 배열로 누적합을 구할 수 있었다.  
하지만 이 문제는 특정 알파벳이 주어진 구간에서 중복된 수를 구하는 문제이다.  
그러므로 2차원 배열을 만들어 누적합을 계산 한 후 문제를 해결할 수 있었다.  

### 코드
```Python
import sys

inStr = input()
num = int(input())

cases = [0]*num
for i in range(num):
    cases[i] = list(sys.stdin.readline().split())
    cases[i][0], cases[i][1], cases[i][2] = ord(cases[i][0])-97, int(cases[i][1]), int(cases[i][2])


sums = [[0]*(len(inStr)+1) for _ in range(26)]
for i in range(26):
    for j in range(1, len(inStr)+1):
        if chr(97+i) == inStr[j-1]:
            sums[i][j] = sums[i][j-1] + 1
        else:
            sums[i][j] = sums[i][j-1]

for i in range(num):
    sys.stdout.write(str(sums[cases[i][0]][cases[i][2]+1] - sums[cases[i][0]][cases[i][1]])+"\n")
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 50점 | 31256KB | 64ms | 590B |

## 3. 개선점
Python으로 실행시키면 50점이 나오고, 서브태스크2에서 시간초과가 발생한다. 여러가지 해결방법을 생각해 다양하게 구현해 보았지만, Python으로는 계속해서 시간초과가 발생하였다.  
혹시 라는 생각으로 PyPy3로 실행시키자 100점을 받을 수 있었다. 하지만 Python으로도 100점을 받기를 원했고, 다른 개선점을 고민하였다.  
2차원 배열의 feature를 줄이는 등 다양한 시도를 했지만, 효과적으로 시간을 감소시킬 수 없었다.  

고민해 봤을 때 해당 코드에서 시간이 가장 많이 소요되는 부분은 누적합을 구하는 부분으로 O(26*len(S))가 소요되었다.  
이 부분의 시간복잡도를 줄여야 Python으로도 문제가 풀릴 것이라는 생각이 들었다.  

누적합을 구할 때 O(len(S))가 되도록 한다면 의미있는 시간감소가 발생할 것으로 판단되었다.  
기존에는 2중 for문으로 누적합을 구했다. 이를 단일 for문으로 바꾸고자 고민했다.  
기존에는 단순히 같은 문자열인 경우 이전 원소 + 1를 하거나 다른 경우 이전 원소 값을 그대로 저장하였다.  
이 방식이 아닌 단순히 이전 행을 복사한 뒤 같은 경우에만 +1 하는 방법으로 바꾸었다.  
이렇게 코드를 바꾸면서, 앞서 만든 누적합 배열을 Transpose할 필요가 있었다.  
열 인덱스 i가 알파벳을 의미하게 하고, 행 인덱스 j가 주어진 문자열의 자리를 의미하게 바꾸었다. 

## 4. 개선사항

```Python
import sys

inStr = input()
num = int(input())

sums = [[0]*(26)]
for i in range(1, len(inStr)+1):
    sums.append(sums[-1][:])
    sums[i][ord(inStr[i-1]) -97] += 1

for i in range(num):
    x, st, end = list(sys.stdin.readline().split())
    x = ord(x)-97
    sys.stdout.write(str(sums[int(end)+1][x] - sums[int(st)][x])+"\n")
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 100점 | 93452KB | 800ms | 328B |

## 5. 개선사항 평가

이전 행을 단순히 복사한 뒤 해당 행에 해당하는 알파벳이 있는 열의 값만 +1을 하게 해준다면 O(len(s))만큼의 시간이 소요된다.  
이를 통해 시간을 효과적으로 감소시켜, Python으로도 문제가 해결되었다.  
