tags: `Programmers`, `DP`
# [Programmers] 산 모양 타일링 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/258705

ID: yuchem2@gmail.com

Date: 2024.10.14

소요시간: 3시간

## 1. 문제설명

### 문제
---
한 변의 길이가 1인 정삼각형 2n+1개를 이어붙여 윗변의 길이가 n, 아랫변의 길이가 n+1인 사다리꼴을 만들 수 있습니다. 이때 사다리꼴의 윗변과 변을 공유하는 n개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양을 만들었습니다. 예를 들어 n이 4이고, 1번째, 2번째, 4번째 정삼각형 위에 정삼각형을 붙인 모양은 다음과 같습니다.

![image](https://github.com/user-attachments/assets/da0fce50-7a82-42ac-ad54-09b96145267b)


이렇게 만든 모양을 정삼각형 타일 또는 정삼각형 2개를 이어 붙인 마름모 타일로 빈 곳이 없도록 채우려고 합니다. 정삼각형 타일과 마름모 타일은 돌려서 사용할 수 있습니다.

![image](https://github.com/user-attachments/assets/84ff1cdd-bc34-4e7d-a54c-ec9218079966)


타일을 놓을 때 다른 타일과 겹치거나 모양을 벗어나게 놓을 수는 없습니다. 위의 예시 모양을 채우는 방법 중 일부는 다음과 같습니다.

![image](https://github.com/user-attachments/assets/3449e4a9-4e21-47b0-b02d-b1afa9e17095)


사다리꼴의 윗변의 길이를 나타내는 정수 n과 사다리꼴 윗변에 붙인 정삼각형을 나타내는 1차원 정수 배열 tops가 매개변수로 주어집니다. 이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 10007로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
+ 1 ≤ n ≤ 100,000
+ tops의 길이 = n
    + tops[i]는 사다리꼴의 윗변과 변을 공유하는 i+1번째 정삼각형의 위쪽에 정삼각형을 붙이는 경우 1, 붙이지 않는 경우 0입니다.

 
### 예제입출력
|n|	tops|	result|
| :--: | :--: | :--: |
|4|	[1, 1, 0, 1]|	149|
|2|	[0, 1]|	11|
|10|	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]|	7704|

## 2. 소스코드

### 알고리즘
해당 문제를 보자마자 동적계획법으로 문제를 해결할 수 있을 것이라고 생각했다.

그래서 이 점을 기준으로 동적계획법을 만들어 코드를 작성하고자 했다. 처음에는 각 마름모 타일을 놓는 것으로 기준을 잡아 코드를 작성하였는데, 이렇게 되니 너무 복잡하고 문제를 해결하는 조건이 많아졌다.

마름모 타일을 놓는 기준으로 문제를 풀려다가 2시간 넘게 소요했다...
너무 코드가 복잡해져서 삼각형 타일을 기준으로 동적계획법을 설계했다.

1. tops를 신경쓰지 않고 사다리꼴의 총 타일수 + 1만큼의 dp 배열을 설계한다. dp[0]은 현재 타일에 아무것도 놓지 않는 것을 의미한다. dp[0] = 1
2. dp[i]는 i만큼의 타일에 놓는 경우의 수를 의미하는데, 기본적으로 삼각형을 배치하는 경우의 수를 의미한다. 기본적으로 dp[i] = dp[i-1]이다.
3. i가 2보다 큰 경우 마름모 타일을 넣을 수 있음으로 dp[i] = dp[i-1] + dp[i-2]가 된다.
4. 만약 i가 2의 배수이고, 위에 추가적으로 삼각형 타일이 있으면, 이전만큼의 삼각형을 추가적으로 넣을 수 있다. 즉 dp[i] = 2 * dp[i-1] + dp[i-2]가 된다.

위 설계를 기준으로 코드를 작성하였다. 위 방법을 사용해 코드를 작성하니 문제가 바로 해결되었다.


### 코드
```Python
def solution(n, tops):
    dp = [0] * (2 * n + 2)
    dp[0] = 1
    for i in range(1, 2 * n + 2):
        dp[i] = dp[i-1]
        if i % 2 == 0 and tops[i//2 - 1] == 1:
            dp[i] = (dp[i] + dp[i-1]) % 10007
        if i >= 2:
            dp[i] = (dp[i] + dp[i-2]) % 10007
    
    return dp[2 * n + 1]
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
