Tags: `BOJ`, `DP`
# [BOJ] 2293번 동전1 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.08.17
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 0.5초 | 4MB | 56440 | 26191 | 19834 | 46.401% |

### 문제
---
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

### 입력
---
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.
### 출력
---
첫째 줄에 경우의 수를 출력한다. 경우의 수는 $2^31$보다 작다.
### 예제입력1
```
3 10
1
2
5
```
### 예제출력1
```
10
```
## 2. 소스코드

### 알고리즘
동전을 이용해 k원을 만들 수 있는 경우의 수를 구하는 문제이다. 여기서 중요한 것은 동전의 수가 제한이 없는 것이다. 
동전에 가치만 이용해 경우의 수를 계산하는데, 이를 위해 dp배열을 k+1 크기로 선언한다. dp[i]는 i원을 만드는 경우의 수를 의미한다. 
이렇게 정의한 후 가치마다 dp 배열을 계산한다. dp[현재 동전의 가치:] 범위의 값을 새로 계산하며, dp[i] = dp[i] + dp[i-현재 동전의 가치]가 된다. 
이를 통해 O(n*k) 정도의 시간복잡도로 문제를 풀 수 있다.

### 코드
```Python
import sys


def problem2293():
    n, k = map(int, input().split())
    coins = [int(sys.stdin.readline().rstrip()) for _ in range(n)]
    dp = [0]*(k+1)
    dp[0] = 1
    for i in range(n):
        for j in range(coins[i], k+1):
            dp[j] = dp[j] + dp[j-coins[i]]
    print(dp[-1])


problem2293()
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 108ms | 307B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
