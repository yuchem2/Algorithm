tags: `BOJ`, `Graph`, `DFS/BFS`, `DP`
# [BOJ] 2618번 경찰차 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.09.06
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초  | 128MB | 15416 | 5017 | 3471  | 33.887% |

### 문제
---
어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.

모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다. N이 6인 경우의 예를 들면 다음과 같다.

<div align="center">
  <img src="https://upload.acmicpc.net/6b5a6518-1801-46c9-9b17-49e8abb3bc88/-/preview/" width="300">  
</div>

이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차2로 부른다. 처음에는 항상 경찰차1은 (1, 1)의 위치에 있고 경찰차2는 (N, N)의 위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고, 연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.

예를 들어 앞의 그림처럼 N=6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치 를 순서대로 (3, 5), (5, 5), (2, 3)이라고 하자. (3, 5)의 사건을 경찰차2에 맡기고 (5, 5)의 사건도 경찰차2에 맡기며, (2, 3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되 고, 더 이상 줄일 수는 없다.

처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.

### 입력
---
첫째 줄에는 동서방향 도로의 개수를 나타내는 정수 N(5 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 처리해야 하는 사건의 개수를 나타내는 정수 W(1 ≤ W ≤ 1,000)가 주어진다. 셋째 줄부터 (W+2)번째 줄까지 사건이 발생된 위치가 한 줄에 하나씩 주어진다. 경찰차들은 이 사건들을 주어진 순서대로 처리해야 한다. 각 위치는 동서방향 도로 번호를 나타내는 정수와 남북방향 도로 번호를 나타내는 정수로 주어지며 두 정수 사이에는 빈칸이 하나 있다. 두 사건이 발생한 위치가 같을 수 있다.

### 출력
---
첫째 줄에 두 경찰차가 이동한 총 거리를 출력한다. 둘째 줄부터 시작하여 (i+1)번째 줄에 i(1 ≤ i ≤ W)번째 사건이 맡겨진 경찰차 번호 1 또는 2를 출력한다.

### 예제입력1
```
6
3
3 5
5 5
2 3
```
### 예제출력1
```
9
2
2
1
```
## 2. 소스코드

### 알고리즘
이 문제를 접근하는데 어려움이 있었다. 그러므로 일단 단순하게 dfs를 이용해서 문제를 풀었다. 당연하게도 시간초과가 발생하였지만 문제를 해결할 수 있는 아이디어를 얻었다. 

해당 문제에서는 case마다 접근할 필요가 있다. 각 case로 이동한 경찰차는 그 위치에서 존재하며 각 case에서 가능한 경우의 수는 경찰차 A 혹은 B가 그 case의 위치로 이동하는 것이다. 그러므로 가능한 총 경우의 수는 $2^n$ 이다. 
이미 계산한 사항에 대해 계산을 줄여 시간을 감소할 필요가 있음으로 동적할당법을 이용해 문제를 해결하였다. case의 수로 이루어진 2차원 배열을 생성한다. 이때 배열은 크기가 case의 수+1인 정방행렬이다.  

각 case에서 이동한 거리는 현재까지 이동한 거리 + 경찰차 A의 위치에서 다음 case의 위치까지의 거리 or 경찰차 B의 위치에서 다음 case의 위치까지의 거리이다. 여기서 시작하면 동적할당법 배열의 점화식을 정립할 수 있다. 

dp[i][j]를 경찰차 A가 i번째 case의 위치에 있고, 경찰차 B가 j번째 case의 위치에 있을 때 max(i, j)부터 n번째 case까지 이동한 최단 거리라고 하자. 그리고, 다음 케이스를 k, 즉 k = max(i, j) + 1이다. 

dp[i][j] = min(dp[i][k] + dist(case[j], case[k]), dp[k][j] + dist(case[i], case[k])) 라고 할 수 있다. 

이렇게 정한 뒤 dfs방식을 이용해 dp 배열을 채워나가면 dp[0][0]이 모든 케이스를 이동하는 최단 거리라고 할 수 있다. 이 문제에서는 최단 거리뿐만 아니라 경로도 출력해야 하므로 역추적 과정이 필요하다. 역추적은 간단하게 dfs와 동일한 작업으로 순회하되, 계산방법만 수정하면 된다. 


### 코드
```Python
import sys
sys.setrecursionlimit(10**6)


def dist(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def problem2618():
    road_num = int(input())
    case_num = int(input())
    cases = [[(1, 1)], [(road_num, road_num)]]
    for _ in range(case_num):
        case = tuple(map(int, sys.stdin.readline().split()))
        cases[0].append(case)
        cases[1].append(case)
    dp = [[-1]*(case_num+1) for _ in range(case_num+1)]

    def dfs(i, j):
        if i == case_num or j == case_num:
            return 0

        if dp[i][j] != -1:
            return dp[i][j]

        k = max(i, j) + 1
        dp[i][j] = min(dfs(k, j) + dist(cases[0][i], cases[0][k]), dfs(i, k) + dist(cases[1][j], cases[1][k]))
        return dp[i][j]

    def back(i, j):
        if i == case_num or j == case_num:
            return

        k = max(i, j) + 1
        if dp[i][j] - dp[k][j] >= dist(cases[0][i], cases[0][k]):
            sys.stdout.write('1\n')
            back(k, j)
        else:
            sys.stdout.write('2\n')
            back(i, k)

    print(dfs(0, 0))
    back(0, 0)


problem2618()

```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 70372KB | 4012ms | 1099B |

## 3. 개선점
x
## 4. 개선사항

x
## 5. 개선사항 평가
x
