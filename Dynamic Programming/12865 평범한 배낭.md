tags: `BOJ`, `knapsack`, `DP`
# [BOJ] 12865번 평범한 배낭 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.05.16
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
|  2초   |  512 MB  | 99858 | 37087 | 23906  | 35.493% |

### 문제
---
이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

### 입력
---
첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

### 출력
---
한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

### 예제입력1
```
4 7
6 13
4 8
3 6
5 12
```
### 예제출력1
```
14
```
## 2. 소스코드

### 알고리즘

해당 문제는 전형적인 배낭 문제이다. DFS, BFS, DP 방법으로 문제를 풀 수 있는데, 해당 문제의 입력 물품 수가 100개이므로 DFS, BFS로는 풀기가 어렵다.  
그러므로 DP로 문제를 풀이해야 한다. 

DP 배열은 최대 무게가 마지막 인덱스로 하여 생성할 수 있다. 예제입력을 통해서 보면 DP 배열은 다음과 같이 생성시킨 후 진행한다. 

|   i   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |

해당 인덱스들은 각 인덱스만큼의 무게에 해당하는 물건, 혹은 두개 이상의 물건을 넣었을 때 가치를 저장하는 배열로 사용할 것이다.  
반복은 각 물품에서 수행되며, 하나의 물품에 대하여 최대 무게부터, 즉 i = len(dp)부터 i = len(dp) - 현재 물건의 무게까지 수행한다.  
즉 시간복잡도가 O(n*k)이다. 

반복을 수행하며 DP 배열의 각 원소를 다음과 같이 정의할 수 있다.  
DP[i] = max(DP[i], DP[i-현재 물건의 무게] + 현재 물건의 가치) 
이를 기반으로 DP 배열을 채우면 다음과 같다. 

먼저 첫번째 물건, w = 6, v = 13일때 다음과 같이 배열이 채워져야 한다. 

|   i   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |   0   |   0   |   0   |   0   |   0   |   0   |   13  |   13  |

두번째 물건, w = 4, v = 8 일때 다음과 같이 배열을 채운다. 

|   i   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |   0   |   0   |   0   |   0   |   8   |   8   |   13  |   13  |

이를 마지막 물건까지 수행하면 DP 배열은 다음과 같이 채워진다. 

|   i   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |   0   |   0   |   0   |   6   |   8   |   12  |   13  |   14  |

이 중의 최댓값을 구하면 문제의 정답이 된다. 

### 코드
```Python
num, maxWeight = map(int, input().split())
weights, values = [0]*num, [0]*num
for i in range(num):
    weights[i], values[i] = map(int, input().split())

crtWeight = 0
dp = [0]*(maxWeight+1)

for i in range(num):
    for j in range(maxWeight, weights[i]-1, -1):
        dp[j] = max(dp[j], dp[j-weights[i]] + values[i])

print(max(dp))
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 35108 KB | 3680ms | 334B |

## 3. 개선점
x

## 4. 개선사항
x

## 5. 개선사항 평가
x
