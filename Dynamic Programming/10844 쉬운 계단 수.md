tags: `BOJ`, `DP`
# [BOJ] 10844번 쉬운 계단 수 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.05.11
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
|   1초   |  256 MB  | 126485 | 40226 | 29117  | 30.082% |

### 문제
---
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.
### 입력
---
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
### 출력
---
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.
### 예제입력1
```
1
```
### 예제출력1
```
9
```
## 2. 소스코드

### 알고리즘
bottom-up 방식으로 문제를 풀면 된다. 먼저 길이가 1인 경우 1-9까지의 수가 모두 계단 수이다.  
길이가 2인 경우 최상위 자릿수(10의 자리)에 위치한 수와 그 아래 자릿수(1의 자리)에 위치한 수의 값의 차이가 1인 경우의 수를 센다.  
길이가 3인 경우 최상위 자릿수(100의 자리)에 위치한 수와 그 아래 자릿수(10의 자리)에 위치한 수의 값의 차이가 1인 경우의 수를 센다.  
이때 센 값을 최상위 자릿수의 위치한 수를 기준으로 배열로 기록한다.  

위와 같은 방법을 반복하며 길이가 N인 경우 경우의 수를 셀 수 있다. 그리고 길이가 N인 경우에서 최상위 숫자가 0일 수 없으므로 이의 경우를 제외하고 길이가 N일 때 계단 수를 모두 센다.  

### 코드
```Python
n = int(input())
if n == 1:
    print(9)
else:
    check = [[0]*10 for x in range(n)]
    for i in range(10):
        check[0][i] = 1
    for i in range(1, n):
        check[i][0] = check[i-1][1]
        for j in range(1, 9):
            check[i][j] = check[i-1][j-1] + check[i-1][j+1]
        check[i][9] = check[i-1][8]

    check[n-1][0] = 0
    print(sum(check[n-1])%1000000000)
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31388KB | 44ms | 382B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
