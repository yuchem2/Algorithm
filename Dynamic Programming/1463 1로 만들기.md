tags: `BOJ`, `Math`, `DP`
# [BOJ] 1463번 1로 만들기 (Python)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.05.11
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
|   0.15초(Python3:1.5초)    |    128MB   | 255794  | 85430 | 54551 | 32.523%  |

### 문제
---
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
### 입력
---
첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.
### 출력
---
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
### 예제입력1
```
10
```
### 예제출력1
```
3
```
## 2. 소스코드

### 알고리즘
bottom-up 방식을 이용해 문제를 풀었다. 1, 2, 3을 1로 만들기 위해선 각각 0, 1, 1번의 연산이 필요하다.  
그리고 4는 2가 되거나 3이 될 수 있다. 2와 3이 1이 되기 위해서는 1번의 연산이 필요하다. 즉 4가 1이 되기 위해서는 최소 2번의 연산이 필요하다.
같은 방법으로 5는 4가 될 수 있다. 4가 1이 되기 위해서는 2번의 연산이 필요하다. 즉 5가 1이 되기 위해서는 최소 3번의 연산이 필요하다.  
6은 3, 2, 5가 될 수 있다. 위와 같은 방법을 사용하면 최소 2번의 2번의 연산이 필요한 것을 알 수 있다.  
이와 같은 방법으로 입력된 값까지 동일하게 수행한다.  

### 코드
```Python
import sys
sys.setrecursionlimit(10**5)

n = int(input())

if n == 1:
    print(0)
elif n == 2 or n == 3:
    print(1)
else:
    cnt = [100] * n
    cnt[0], cnt[1], cnt[2] = 0, 1, 1
    x = 3
    while x <= n:
        num1, num2 = 100, 100
        if x % 3 == 0:
            num1 = cnt[x // 3 - 1] + 1
        if x % 2 == 0:
            num2 = cnt[x // 2 - 1] + 1

        cnt[x - 1] = min(num1, num2, cnt[x - 2] + 1)
        x += 1

    print(cnt[n-1])
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 39068 KB | 824 ms | 454B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
