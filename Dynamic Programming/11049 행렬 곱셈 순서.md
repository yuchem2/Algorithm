tags: `BOJ`, `DP`
# [BOJ] 11049번 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.08.11
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초 | 256 MB | 28456 | 12940 | 9334 | 44.365% |

### 문제
---
크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.

예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.

+ AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.
+ BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.
같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.

행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.
### 입력
---
첫째 줄에 행렬의 개수 N(1 ≤ N ≤ 500)이 주어진다.

둘째 줄부터 N개 줄에는 행렬의 크기 r과 c가 주어진다. (1 ≤ r, c ≤ 500)

항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.

### 출력
---
첫째 줄에 입력으로 주어진 행렬을 곱하는데 필요한 곱셈 연산의 최솟값을 출력한다. 정답은 $2^{31}-1$ 보다 작거나 같은 자연수이다. 또한, 최악의 순서로 연산해도 연산 횟수가 $2^{31}-1$보다 작거나 같다.
### 예제입력1
```
3
5 3
3 2
2 6
```
### 예제출력1
```
90
```
## 2. 소스코드

### 알고리즘
앞서 풀었던 파일 합치기 문제와 동일한 알고리즘이다. 점화식에서만 차이가 존재하고, 문제를 푸는 아이디어는 동일하다. 항상 행렬 곱은 두 개의 행렬 곱을 곱한 후 완성된 행렬을 다시 곱하는 방식으로 n개의 행렬을 곱할 수 있다. 
행렬 곱에는 규칙이 있으나, 문제에서 항상 곱할 수 있는 순서로 곱해진다고 하였으므로 이를 무시할 수 있다. 그래서 순서에 대해서만 생각해 dp를 정의한다. dp[i][j]를 i~j번째 행렬들의 곱 연산 요구량으로 정의를 하자. 
그러면 dp[i][j]를 i, j 사이에 존재하는 임의의 행렬 m을 기준으로 곱했다고 생각할 수 있고, 이 m 행렬이 최소 요구량을 만든다고 가정한다. 즉, dp[i][j] = d[i][m] + d[m+1][j] + i의 row * m의 column * j의 column 이다. 이를 점화식으로 정하고, 3중 for문을 이용해 구현한다. 


### 코드
```Python
import sys


def problem11049():
    num = int(input())
    cases = [list(map(int, sys.stdin.readline().split())) for _ in range(num)]
    dp = [[0]*num for _ in range(num)]
    inf = 2**32-1

    for d in range(1, num):
        for i in range(0, num-d):
            j = i + d
            dp[i][j] = inf
            for m in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m+1][j] + cases[i][0]*cases[m][1]*cases[j][1])

    print(dp[0][num-1])


problem11049()
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 117560KB | 824ms | 481B |

## 3. 개선점
해당 결과는 PyPy3를 이용해 얻은 결과이다. Python3에서는 시간초과가 발생하였다. 실행시간을 줄이기 위해 여러가지 시행을 수행하였다. 가능한 m의 범위를 한정하려고 하였으나, 행렬 곱의 특징상 한정하기가 어려웠다. 
그러므로 연산 수행을 줄이기 위해 노력하였다. 문제에서 최댓값이 $2^32-1$이라고 하여 이를 기준으로 문제를 풀었으나 매우 큰 수이므로, 비교 연산에서 시간이 많이 소모될 수 밖에 없었다. 
이를 줄이기 위해 최댓값을 정하고 비교하는 것이 아니라, 구한 수끼리 비교하고자 코드를 수정하였다. 

## 4. 개선사항
```Python
import sys


def problem11049():
    num = int(input())
    cases = [list(map(int, sys.stdin.readline().split())) for _ in range(num)]
    dp = [[0]*num for _ in range(num)]

    for d in range(1, num):
        for i in range(0, num-d):
            j = i + d
            cost = cases[i][0]*cases[j][1]
            dp[i][j] = min(dp[i][m] + dp[m+1][j] + cases[m][1]*cost for m in range(i, j))

    print(dp[0][num-1])


problem11049()
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 365356KB | 3888ms | 452B |

## 5. 개선사항 평가
Python에서 사용할 수 있는 for문 방식을 응용해 최댓값과의 비교를 생략하였다. 이를 통해 Python3에서도 문제를 해결할 수 있었다.  
