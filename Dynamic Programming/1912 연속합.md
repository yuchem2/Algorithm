tags: `BOJ`, `Maximum-Subarray-Sum`, `DP`, `Kadane Algorithm
# [BOJ] 1912번 연속합 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.04.04
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초 | 128MB  | 122093 | 44548 | 31410 | 35.130%  |

### 문제
---
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
### 입력
---
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.
### 출력
---
첫째 줄에 답을 출력한다.

### 예제 입력1
```
10
10 -4 3 1 5 6 -35 12 21 -1
```

### 예제 출력1
```
33
```

## 2. 소스코드
### 알고리즘
해당 문제는 수열에서 연속된 몇 개의 수를 선택해서 구할 수 있는 가장 큰 합을 구하는 것이다. 

예제에서 정답이 $33 = 12 + 21$인 것을 통해 시작 index의 시점은 상관 없지만, 종료시점까지 연속되어야 하는 것을 알 수 있다. 

예제에서 결과를 구한 예시를 통해 생각해보았다.

lcs(1) = 10

lcs(2) = max(10-4, -4) = 6

lcs(3) = max(10-4+3, 3) = 9

lcs(4) = max(10-4+3+1, 1) = 10

lcs(5) = max(10-4+3+1+5, 5) = 15

lcs(6) = max(10-4+3+1+5+6, 6) = 21

lcs(7) = max(10-4+3+1+5+6-35, -35) = -14

lcs(8) = max(10-4+3+1+5+6-35+12, 12) = 12

lcs(9) = max(12+21, 21) = 33

lcs(10) = max(12+21-1, -1) = 3

위와 같은 순서를 보면 lcs(n)을 일반화 할 수 있다.

$$lcs(n) = max(lcs(n-1) + inSequence(n), inSequence(n))$$

이때 inSequnce는 n개의 정수로 이루어진 임의의 수열이다. 

### 코드
```python
n = int(input())
intArray = list(map(int, input().split()))

cur = 0
best = -10 ** 8
for num in intArray:
    cur = max(num, cur + num)
    best = max(best, cur)

print(best)
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 38964KB | 104ms | 174B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
