tags: `BOJ`, `knapsack`, `DP`
# [BOJ] 2629번 양팔저울 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.08.16
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초 | 128MB | 20662 | 6656 | 4812 | 32.896% |

### 문제
양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.

무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.

구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.
<p align="center">
  <img src="https://upload.acmicpc.net/ce5b29f5-9e03-473b-97db-ce9fd740fde2/-/preview/" width="300px">
</p>

<그림 1> 구슬이 3g인지 확인하는 방법 (
$\boxed{1}$은 1g인 추, 
$\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)

<그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.

추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.

<p align="center">
  <img src="https://upload.acmicpc.net/883fb22a-7516-46e1-937d-2ddc4df94572/-/preview/" width="300px">
</p>

<그림 2> 구슬이 5g인지 확인하는 방법
### 입력
---
첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.
### 출력
---
주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.
### 예제입력1
```
2
1 4
2
3 2
```
### 예제출력1
```
Y N
```
## 2. 소스코드

### 알고리즘
문제 분류는 냅색 문제로 분류가 되어있었다. 
하지만 문제를 직관적으로 봤을 때 추로 만들 수 있는 무게의 경우를 dp배열로 저장을 하고, 추에 따라 이를 찾으면 문제 제한이 적은 양이기 때문에 1초안에 문제가 풀릴 것이라고 생각하였다. 
이러한 가정으로, dp 배열을 입력된 추의 무게의 합+1 길이를 갖도록 배열을 만든다. 문제 제한에서 최대 제한이 15000이기 때문에 메모리 적으로도 여유가 있다.  
이런식으로, 코드를 작성해 O(dp(len)*wieght_num)시간 복잡도를 이용해 문제를 해결할 수 있다. 

### 코드
```Python
def check(marble, dp):
    if len(dp) - 1 < marble:
        print("N", end=" ")
        return
    if dp[marble] == 1:
        print("Y", end=" ")
    else:
        for i in range(len(dp)-marble-1):
            if dp[i] and dp[i+marble]:
                print("Y", end=" ")
                return
        print("N", end=" ")


def problem2629():
    weight_num = int(input())
    weights = list(map(int, input().split()))
    marble_num = int(input())
    marbles = list(map(int, input().split()))
    dp = [0]*(sum(weights)+1)
    dp[0] = 1
    for i in range(weight_num):
        for j in range(len(dp)-1, -1, -1):
            if dp[j]:
                dp[j+weights[i]] = 1

    for marble in marbles:
        check(marble, dp)


problem2629()
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 56ms | 788B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
