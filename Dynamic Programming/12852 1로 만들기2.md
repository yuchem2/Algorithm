tags: `BOJ`, `DP`
# [BOJ] 12582번 1로 만들기2 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.09.01
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 0.5초 | 512MB | 24667 | 11485 | 9170 | 47.076% |

### 문제
---
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력
---
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 자연수 N이 주어진다.

### 출력
---
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

둘째 줄에는 N을 1로 만드는 방법에 포함되어 있는 수를 공백으로 구분해서 순서대로 출력한다. 정답이 여러 가지인 경우에는 아무거나 출력한다.

### 예제입력1
```
10
```
### 예제출력1
```
3
10 9 3 1
```
## 2. 소스코드

### 알고리즘
처음에 단순히 그래프 문제라고 생각해 bfs를 적용해서 문제를 풀었다. 하지만 문제를 다시 복기해보았을 때 bfs로 풀 이유가 없었고, 다이나밍 프로그래밍 기법으로 간단하게 해결할 수 있는 문제였다.  

bfs의 predecessor 아이디어만 가져와서 말이다. dp 배열을 2 x N크기의 2차원 배열로 생성한다. 그리고 dp[i][0]은 i값을 만들기 위한 최소 연산 수, dp[i][1]은 i값을 만든 이전 수를 의미하도록 정의한다.  
이렇게 문제를 풀면 O(n) 순회로 문제를 빠르게 해결할 수 있다. 

### 코드
```Python
import sys


def problem12852():
    n = int(input())
    dp = [[int(1e6)+1, -1] for _ in range(n+1)]
    dp[1] = [0, -1]
    for u in range(1, n+1):
        c = dp[u][0]
        if u*3 <= n and dp[u*3][0] > c + 1:
            dp[u*3][0], dp[u*3][1] = c+1, u

        if u*2 <= n and dp[u*2][0] > c + 1:
            dp[u*2][0], dp[u*2][1] = c+1, u

        if u+1 <= n and dp[u+1][0] > c + 1:
            dp[u+1][0], dp[u+1][1] = c+1, u

    print(dp[n][0])
    i = n
    while i != -1:
        sys.stdout.write(str(i)+" ")
        i = dp[i][1]


problem12852()

```
| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 150096KB | 940ms | 562B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
