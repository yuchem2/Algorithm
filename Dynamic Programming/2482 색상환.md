tags: `BOJ`, `DP`
# [BOJ] 2482번 색상환 (JAVA)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2024.01.10
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1초  | 128MB | 12603 | 4558 | 3303 | 35.379% |

### 문제
---
색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.
<div align="center">
  <img src="https://upload.acmicpc.net/069ffaec-e512-4352-bbc4-5ed9a20851ee/-/preview/" height="250"/>
</div>

색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.

주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.

주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.

### 입력
---
입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다. 

### 출력
---
첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.

### 예제입력1
```
4
2
```
### 예제출력1
```
2
```
## 2. 소스코드

### 알고리즘
이 문제는 dynamic programming 기법으로 해결할 수 있다.
이 문제에서 사용할 배열을 dp[n][k]로 정의하고, 이를 n개의 색상으로 구성된 색상환에서 k개를 인접하지 않게 뽑는 경우의 수라고 정의한다.

그리고 문제의 조건에 따라 dp[i][0] = 1, dp[i][1] = i 라고 정의할 수 있다.
dynamic programming 기법을 사용할 것이므로 점화식을 세워야 한다. dp[i][j]에 대해서 j번째 색을 칠하는 경우와 안칠하는 경우가 존재할 수 있고, 각 경우의 수는 다음과 같이 정의할 수 있다.
+ j번째 색을 색칠하지 않는 경우는 이미 j개의 색이 모두 선택된 것으로 판단할 수 있다. 그러므로 dp[i-1][j] 만큼이라고 판단할 수 있다.
+ j번째 색을 칠하는 경우는 이전에 j-1개의 색이 칠해져있음을 의미한다. j번째 색을 칠하기 위해서는 그 색과 인접한 색이 모두 칠해져 있지 않아야 한다. 즉, dp[i-2][j-1] 만큼의 경우의 수가 존재할 수 있다고 판단할 수 있따.

위 두 결론에 따라 점화식은 dp[i][j] = dp[i-1][j] + dp[i-2][j-1] 로 세울 수 있다. 
이 점화식을 통해 코드를 작성하면 문제를 해결할 수 있다. 

### 코드
```java
import java.io.*;

public class problem2482 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n, k, mod;
        mod = 1000000003;
        n = Integer.parseInt(br.readLine());
        k = Integer.parseInt(br.readLine());

        int[][] dp = new int[n+1][k+1];
        for(int i=0; i<=n; i++) {
            dp[i][1] = i;
            dp[i][0] = 1;
        }

        for(int i=2; i<=n; i++) {
            for(int j=2; j<=k; j++)
                dp[i][j] = (dp[i-2][j-1] + dp[i-1][j]) % mod;
        }

        System.out.println((dp[n-1][k] + dp[n-3][k-1]) % mod);
    }
}

```
| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 17212KB | 148ms | 677B |

## 3. 개선점
x
## 4. 개선사항
x

## 5. 개선사항 평가
x
