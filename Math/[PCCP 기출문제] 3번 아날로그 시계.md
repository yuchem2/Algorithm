tags: `Programmers`, `Math`
# [Programmers] [PCCP 기출문제] 3번 아날로그 시계 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/250135

ID: yuchem2@gmail.com

Date: 2024.10.13

소요시간: 1시간30분

## 1. 문제설명

### 문제
---
시침, 분침, 초침이 있는 아날로그시계가 있습니다. 시계의 시침은 12시간마다, 분침은 60분마다, 초침은 60초마다 시계를 한 바퀴 돕니다. 따라서 시침, 분침, 초침이 움직이는 속도는 일정하며 각각 다릅니다. 이 시계에는 초침이 시침/분침과 겹칠 때마다 알람이 울리는 기능이 있습니다. 당신은 특정 시간 동안 알람이 울린 횟수를 알고 싶습니다.

다음은 0시 5분 30초부터 0시 7분 0초까지 알람이 울린 횟수를 세는 예시입니다.

+ 가장 짧은 바늘이 시침, 중간 길이인 바늘이 분침, 가장 긴 바늘이 초침입니다.
+ 알람이 울리는 횟수를 세기 시작한 시각은 0시 5분 30초입니다.
+ 이후 0시 6분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다.
+ 약 0시 6분 0.501초에 초침과 시침이 겹칩니다. 이때 알람이 한 번 울립니다.
+ 이후 0시 6분 6초까지 초침과 시침/분침이 겹치는 일은 없습니다.
+ 약 0시 6분 6.102초에 초침과 분침이 겹칩니다. 이때 알람이 한 번 울립니다.
+ 이후 0시 7분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다.

0시 5분 30초부터 0시 7분 0초까지는 알람이 두 번 울립니다. 이후 약 0시 7분 0.584초에 초침과 시침이 겹쳐서 울리는 세 번째 알람은 횟수에 포함되지 않습니다.

다음은 12시 0분 0초부터 12시 0분 30초까지 알람이 울린 횟수를 세는 예시입니다.

+ 알람이 울리는 횟수를 세기 시작한 시각은 12시 0분 0초입니다.
+ 초침과 시침, 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 이와 같이 0시 정각, 12시 정각에 초침과 시침, 분침이 모두 겹칠 때는 알람이 한 번만 울립니다.
+ 이후 12시 0분 30초까지 초침과 시침/분침이 겹치는 일은 없습니다.
+ 12시 0분 0초부터 12시 0분 30초까지는 알람이 한 번 울립니다.

알람이 울리는 횟수를 센 시간을 나타내는 정수 h1, m1, s1, h2, m2, s2가 매개변수로 주어집니다. 이때, 알람이 울리는 횟수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
+ 0 ≤ h1, h2 ≤ 23
+ 0 ≤ m1, m2 ≤ 59
+ 0 ≤ s1, s2 ≤ 59
+ h1시 m1분 s1초부터 h2시 m2분 s2초까지 알람이 울리는 횟수를 센다는 의미입니다.
  + h1시 m1분 s1초 < h2시 m2분 s2초
  + 시간이 23시 59분 59초를 초과해서 0시 0분 0초로 돌아가는 경우는 주어지지 않습니다.

### 예제입출력

| h1 |	m1	|s1|	h2|	m2|	s2	|result|
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | 
|0|	5	|30|	0|	7|	0|	2|
|12|	0	|0|	12|	0	|30|	1|
|0|	6|	1|	0|	6	|6	|0|
|11|	59|	30	|12|	0|	0|	1|
|11|	58|	59	|11|	59|	0|	1|
|1|	5	|5	|1	|5	|6	|2|
|0|	0|	0|	23|	59|	59|	2852|


## 2. 소스코드

### 알고리즘
처음은 해당 문제를 시계에서 시침, 분침, 초침의 위치를 1초당 업데이트하면서 이전 1초의 위치와 지금 1초의 위치를 비교해 문제를 해결하고자 했다.
그러나 이 방법을 구상하고 코드를 작성하고 실행시켰을 때 풀이 자체가 완벽하지 않는 기범이라는 생각이 들었다. 그 이유는 다음과 같았다.

1. 시침, 분침, 초침 세 개가 겹치는 경우를 하나로 카운트하지 않음.
2. 정확하게 두 바늘이 겹쳤다는 시점이 수학적으로 확실하지 않음.

위 문제 때문에 문제를 다른 방법으로 접근하고자 했다.

1. 초침은 1분당 한바퀴를 돌기 떄문에 1분당 시침과 초침과 무조건 겹칠 수 밖에 없다.(분당 2번 충돌)
2. 시침과 분침, 초침 세개가 겹치는 경우는 시침과 분침이 겹치는 경우와 같다. 시침과 분침은 1시간에 한번 겹친다.(시간당 1번 충돌)
3. 11시59분에서 12시, 23시39분에서 24시로 넘어갈 때는 초침은 분침과 시침과 겹칠 수 없다. (해당 경우에 충돌 횟수 2회 감소)
4. 0시00분00초, 12시00분00초는 1분이 지날때 초침이 겹치지 않는다. 오직 0시00분00초 혹은 12시00분00초에서만 겹치게 된다.  

위 근거를 통해 수식을 세우면 $h * 120 + m * 2 - h$라는 수식을 세울 수 있다. 그래서 시작 시간의 충돌횟수와 끝나는 시간의 충돌 횟수를 계산해서 빼고자 하였다.

위 수식에 23:59:59를 넣으면 $collision = 23 * 120 + 59 * 2 - 23 = 2760 + 118 - 23 = 2855$가 된다. 11시 59분지점을 지났기 때문에 -2를 추가로 해준다.
그리고 0:00:00를 넣으면 $collision = 0 * 120 + 0 * 2 - 0 = 0$이 된다. 그러나 최초 시점에서 한번 겹치기 때문에 1번 겹친다.
23:59:59의 결과에서 0:00:00 결과를 빼게 되면, $2855 - 2 - 0 - 1 = 2852$가 된다.

위 근거를 기준으로 코드를 작성했다. 여기서 추가적으로, 초침의 위치를 생각하지 않고, 0초를 기준으로 충돌 횟수를 계산했기 때문에, 
시계의 현재 바늘 위치를 통해 초침의 위치가 분침, 시침보다 각도가 높은 경우 충돌 횟수를 더하는 작업이 추가적으로 필요했다. 

### 코드
```Python
def get_count(h, m, s):
    seconds = (s * 6) % 360 
    mins = (m * 6 + s * 0.1) % 360
    hours = (h * 30 + m * 0.5 + s / 120) % 360
    
    collisions = h * 120 + m * 2 - h
    if seconds >= mins:
        collisions += 1
    if seconds >= hours:
        collisions += 1
        
    if h >= 12:
        collisions -= 2
    
    return collisions

def solution(h1, m1, s1, h2, m2, s2):
    answer = get_count(h2, m2, s2) - get_count(h1, m1, s1)
    
    if h1 in [0, 12] and m1 == 0 and s1 == 0:
        answer += 1
    
    return answer
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
