tags: `Programmer`, `Brute Force`
# [Programmers] 상담원 인원 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/214288

ID: yuchem2@gmail.com

Date: 2024.10.22

소요시간: 1시간 10분

## 1. 문제설명

### 문제
---

현대모비스는 우수한 SW 인재 채용을 위해 상시로 채용 설명회를 진행하고 있습니다. 채용 설명회에서는 채용과 관련된 상담을 원하는 참가자에게 멘토와 1:1로 상담할 수 있는 기회를 제공합니다. 채용 설명회에는 멘토 n명이 있으며, 1~k번으로 분류되는 상담 유형이 있습니다. 각 멘토는 k개의 상담 유형 중 하나만 담당할 수 있습니다. 멘토는 자신이 담당하는 유형의 상담만 가능하며, 다른 유형의 상담은 불가능합니다. 멘토는 동시에 참가자 한 명과만 상담 가능하며, 상담 시간은 정확히 참가자가 요청한 시간만큼 걸립니다.

참가자가 상담 요청을 하면 아래와 같은 규칙대로 상담을 진행합니다.

+ 상담을 원하는 참가자가 상담 요청을 했을 때, 참가자의 상담 유형을 담당하는 멘토 중 상담 중이 아닌 멘토와 상담을 시작합니다.
+ 만약 참가자의 상담 유형을 담당하는 멘토가 모두 상담 중이라면, 자신의 차례가 올 때까지 기다립니다. 참가자가 기다린 시간은 참가자가 상담 요청했을 때부터 멘토와 상담을 시작할 때까지의 시간입니다.
+ 모든 멘토는 상담이 끝났을 때 자신의 상담 유형의 상담을 받기 위해 기다리고 있는 참가자가 있으면 즉시 상담을 시작합니다. 이때, 먼저 상담 요청한 참가자가 우선됩니다.

참가자의 상담 요청 정보가 주어질 때, 참가자가 상담을 요청했을 때부터 상담을 시작하기까지 기다린 시간의 합이 최소가 되도록 각 상담 유형별로 멘토 인원을 정하려 합니다. 단, 각 유형별로 멘토 인원이 적어도 한 명 이상이어야 합니다.

예를 들어, 5명의 멘토가 있고 1~3번의 3가지 상담 유형이 있을 때 아래와 같은 참가자의 상담 요청이 있습니다.

참가자의 상담 요청

| 참가자 번호 | 시각  | 상담 시간 | 상담 유형  |
|--------|-----|-------|--------|
| 1번 참가자 | 10분 | 60분   | 1번 유형  |
| 2번 참가자 | 15분 | 100분  | 3번 유형  |
| 3번 참가자 | 20분 | 30분   | 1번 유형  |
| 4번 참가자 | 30분 | 50분   | 3번 유형  |
| 5번 참가자 | 50분 | 40분   | 1번 유형  |
| 6번 참가자 | 60분 | 30분   | 2번 유형  |
| 7번 참가자 | 65분 | 30분   | 1번 유형  |
| 8번 참가자 | 70분 | 100분  | 2번 유형  |

이때, 멘토 인원을 아래와 같이 정하면, 참가자가 기다린 시간의 합이 25로 최소가 됩니다.

| 1번 유형 | 2번 유형 | 3번 유형  |
|-------|-------|--------|
| 2명    | 1명    | 2명     |


1번 유형
1번 유형을 담당하는 멘토가 2명 있습니다.

+ 1번 참가자가 상담 요청했을 때, 멘토#1과 10분~70분 동안 상담을 합니다.
+ 3번 참가자가 상담 요청했을 때, 멘토#2와 20분~50분 동안 상담을 합니다.
+ 5번 참가자가 상담 요청했을 때, 멘토#2와 50분~90분 동안 상담을 합니다.
+ 7번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 1번 참가자의 상담이 끝날 때까지 5분 동안 기다리고 멘토#1과 70분~100분 동안 상담을 합니다.

2번 유형
2번 유형을 담당하는 멘토가 1명 있습니다.

+ 6번 참가자가 상담 요청했을 때, 멘토와 60분~90분 동안 상담을 합니다.\
+ 8번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 6번 참가자의 상담이 끝날 때까지 20분 동안 기다리고 90분~190분 동안 상담을 합니다.

3번 유형
3번 유형을 담당하는 멘토가 2명 있습니다.

+ 2번 참가자가 상담 요청했을 때, 멘토#1과 15분~115분 동안 상담을 합니다.
+ 4번 참가자가 상담 요청했을 때, 멘토#2와 30분~80분 동안 상담을 합니다.

상담 유형의 수를 나타내는 정수 k, 멘토의 수를 나타내는 정수 n과 참가자의 상담 요청을 담은 2차원 정수 배열 reqs가 매개변수로 주어집니다. 멘토 인원을 적절히 배정했을 때 참가자들이 상담을 받기까지 기다린 시간을 모두 합한 값의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
+ 1 ≤ k ≤ 5
+ k ≤ n ≤ 20
+ 3 ≤ reqs의 길이 ≤ 300
  + reqs의 원소는 [a, b, c] 형태의 길이가 3인 정수 배열이며, c번 유형의 상담을 원하는 참가자가 a분에 b분 동안의 상담을 요청했음을 의미합니다.
  + 1 ≤ a ≤ 1,000
  + 1 ≤ b ≤ 100
  + 1 ≤ c ≤ k
  + reqs는 a를 기준으로 오름차순으로 정렬되어 있습니다.
  + reqs 배열에서 a는 중복되지 않습니다. 즉, 참가자가 상담 요청한 시각은 모두 다릅니다.
 
### 예제입출력

| k | n | reqs                                                                                                       | result  |
|---|---|------------------------------------------------------------------------------------------------------------|---------|
| 3 | 5 | [[10, 60, 1], [15, 100, 3], [20, 30, 1], [30, 50, 3], [50, 40, 1], [60, 30, 2], [65, 30, 1], [70, 100, 2]] | 25      |
| 2 | 3 | [[5, 55, 2], [10, 90, 2], [20, 40, 2], [50, 45, 2], [100, 50, 2]]                                          | 90      |

## 2. 소스코드

### 알고리즘

mentor m명을 유형 k개에 어떻게 분배한 결과에 따른 총 wait 시간을 구하는 문제이다. 문제 설명에 따르면 상담을 하게 되는 경우는 선입선출 방식이다. 또한, 상담 참가자가 신청한 시각은 모두 다르고, 이미 오름차순으로 정렬되어 있다.
그러므로, 각 mentor 조합 분배에 따른 총 wait 시간을 구하는 경우는 매우 쉽다. reqs를 순차적으로 탐색하면서 각 k유형에 따라 가디라는 시간이 최소가 되도록 멘토를 차례대로 분배하면 된다. 

어떤 조합이 최소가 되는 지를 구하는 게 문제의 핵심이다. 처음에는 greedy하게 문제를 풀려고 하였다. 
1. 모든 k유형에 멘토를 1명씩 분배한 결과를 계산한 후 각 유형의 wait 시간을 따로 계산한다.
2. 유형의 시간 중 최대 소요시간인 결과의 멘토를 1증가시킨다.
3. 1-2를 m명이 모두 분배될 때까지 반복한다.

해당 방법을 수행한 결과 테스트 케이스는 통과하였지만, 실행결과에서 두 케이스만 통과할 수 있었다. 문제를 복기했을 때 각 유형의 최대시간을 줄인다고, 총 소요시간이 반드시 최소라는 근거는 없었다. 
그래서 m명을 분배하는 모든 케이스를 탐색하고자 하였다. 
1. 각 유형에 분배될 수 있는 최대 멘토의 수는 n-k+1이다. 이를 product를 이용해 1~n-k+1를 k번 반복한 조합을 모두 구한 뒤 그 조합의 합이 n인 조합에서 총 wait 시간을 구한다.
2. 현재 총 wait 시간이 이전에 구한 최소 wait 시간보다 작은 경우 최소 wait 시간을 업데이트한다.
3. 1~2를 모든 유형에 반복한다.

이 방법을 통해 문제를 해결할 수 있었다. 완전 탐색이라 시간이 더 많이 소요될 수도 있는데, 그래서 소요시간을 아래와 같이 계산해봤다.

+ 각 유형에 따라 wait 시간을 구하는 시간 = 최악: O(len(reqs) * (n-k+1)) 평균: O((len(reqs) * n) / k^2)
+ 모든 유형 탐색 시간 = O((n-k+1)^k)
+ solution을 구하는 시간 = O(len(reqs) * (n-k+1)^(k+1)))

완전 탐색시간이 매우 오래 걸리지만, 문제의 제한시간을 확인해보면 n-k+1의 최대 값은 20이다. k의 최대 값은 5이다. 각 유형에 따라 wait 시간을 구할 때는 평균 시간이 최악 시간보다 낮다. 이는 k가 커질수록 mentor가 분산될 확률이 높고, k가 작아질 수록 mentor가 분산될 확률이 낮기 때문이다. 

시간을 구하는  reqs의 길이도 최대 300이기 때문에 최악의 경우라도 2~3초 이내에 문제를 해결할 수 있다고 생각이 들고, 실제 실행결과에서도 1942.33ms가 최대 수치로 파악됬다.

### 코드
```python
from itertools import product

def solution(k, n, reqs):
    def schedule(mentor):
        waits = 0
        cur = [[0] * mentor[i] for i in range(k)]
        for req in reqs:
            min_i = 0
            case = req[2] - 1
            for i in range(mentor[case]):
                if cur[case][i] <= req[0]:
                    min_i = i
                    break
                else:
                    if cur[case][min_i] > cur[case][i]:
                        min_i = i
            else:
                waits += cur[case][min_i] - req[0]
            cur[case][min_i] = max(req[0] + req[1], cur[case][min_i] + req[1])
    
        return waits
    
    answer = 123456789
    for mentor in product(range(1, n-k+2), repeat=k):
        if sum(mentor) == n:
            answer = min(answer, schedule(mentor))
    
    return answer
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
