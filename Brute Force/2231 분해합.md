tags: `BOJ`, `Math`, `Brute Force`
# [BOJ] 2231번 분해합 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.03.09
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
|  2초  |  192MB  | 118828 | 54599 | 42911 | 45.280%  |

### 문제
---
어떤 자연수 N이 있을 때, 그 자연수 **N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.** 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
### 입력
---
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

### 출력
---
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

### 예제 입력1
```
216
```
### 예제 출력1
```
198
```

## 2. 소스코드
### 알고리즘
브루트 포스 알고리즘으로 시작값부터 주어진 자연수 n까지의 경우의 수를 모두 검사해 생성자가 존재하는지 확인할 수 있다. 

하지만 1부터 찾는다면 의미없는 반복이 반복되고, 최대 값이 입력되는 경우 1000000의 반복을 반복하게 된다. 그러므로 시작값을 정하는 것이 중요하다. 

분해합은 생성자와 그 생성자의 각 자리수의 합이다. 그러므로 생성자는 분해합의 결과보다 무조건 작을 수 밖에 없다. 

그러므로 생성자의 최고 자리수에 올 수 있는 수는 항상 분해합의 최고자리수보다 작을 수 밖에 없다.

그 외의 자리수는 모두 0~9까지의 경우의 수를 가질 수 있다. 

이러한 논리로 봤을 때 최소 생성자는 다음과 같이 정의 할 수 있다. (가능한 최소 생성자 = m, 자연수 = n, n의 길이 = l)

$$m = n - ([n]^{10^{(l-1)}} + (l-1)*9)$$

이를 통해 반복을 최소한으로 줄인 후 문제를 풀 수 있었다. 

### 코드
```python
import sys

input = sys.stdin.readline
print = sys.stdout.write

inNum = int(input())

numLen = len(str(inNum))
stNum = inNum - (inNum // (10 ** (numLen - 1)) + 9 * (numLen-1))

ctorNum = 0
for i in range(stNum, inNum+1):
    calculateNum = i + sum(list(map(int, str(i))))
    if calculateNum == inNum:
        ctorNum = i
        break

print(str(ctorNum))
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 44ms | 357B |


## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
