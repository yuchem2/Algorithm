tags: `Programmers`, `Graph`, `DFS/BFS`
# [Programmers] 미로 탈출 명령어 (PYTHON)
Programmers 코딩테스트 연습: 

ID: yuchem2@gmail.com

Date: 2024.11.21

소요시간: 45분

## 1. 문제설명

### 문제
---
n x m 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다.

단, 미로를 탈출하는 조건이 세 가지 있습니다.

1. 격자의 바깥으로는 나갈 수 없습니다.
2. (x, y)에서 (r, c)까지 이동하는 거리가 총 k여야 합니다. 이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다.
3. 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다.

이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다.

+ l: 왼쪽으로 한 칸 이동
+ r: 오른쪽으로 한 칸 이동
+ u: 위쪽으로 한 칸 이동
+ d: 아래쪽으로 한 칸 이동

예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 "lul"로 나타낼 수 있습니다.

미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다.

예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다.

```
....
..S.
E...
```
미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다. .은 빈 공간, S는 출발 지점, E는 탈출 지점입니다.

탈출까지 이동해야 하는 거리 k가 5라면 다음과 같은 경로로 탈출할 수 있습니다.

1. lldud
2. ulldd
3. rdlll
4. dllrl
5. dllud
6. ...

이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다.

격자의 크기를 뜻하는 정수 n, m, 출발 위치를 뜻하는 정수 x, y, 탈출 지점을 뜻하는 정수 r, c, 탈출까지 이동해야 하는 거리를 뜻하는 정수 k가 매개변수로 주어집니다. 이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요. 단, 위 조건대로 미로를 탈출할 수 없는 경우 "impossible"을 return 해야 합니다.

### 제한사항
+ 2 ≤ n (= 미로의 세로 길이) ≤ 50
+ 2 ≤ m (= 미로의 가로 길이) ≤ 50
+ 1 ≤ x ≤ n
+ 1 ≤ y ≤ m
+ 1 ≤ r ≤ n
+ 1 ≤ c ≤ m
+ (x, y) ≠ (r, c)
+ 1 ≤ k ≤ 2,500

### 예제입출력
| n | m | x | y | r | c | k | result       |
|---|---|---|---|---|---|---|--------------|
| 3 | 4 | 2 | 3 | 3 | 1 | 5 | "dllrl"      |
| 2 | 2 | 1 | 1 | 2 | 2 | 2 | "dr"         |
| 3 | 3 | 1 | 2 | 3 | 3 | 4 | "impossible" |

## 2. 소스코드

### 알고리즘

처음에는 bfs로 모든 경로를 탐색하면서 문제를 풀었다. 

bfs 특성상 모든 경로를 탐색해야 함으로 방문한 지점에 대한 관리가 필요했는데, 문제는 모든 지점을 2번 이상 방문할 수 있다는 조건이 있어 방문한 지점을 어떻게 관리할지에 대한 문제가 생겼다.

그래서 현재 시점에서 맞는 길이 아니면 backtracking해 이전 지점의 경로부터 시작하면서 탐색하는 방식이 더 문제 풀이에 유효할 것이라고 생각했고, 그래서 dfs로 풀이를 수정했다. 

dfs로 수정하면서 방문한 지점을 관리하지 않고, 새로운 "종료조건"들을 아래와 같이 추가하는 방식으로 dfs가 탐색이 이뤄지도록 구현했다.

1. 현재 위치에서 종료 지점까지의 거리(앞으로 최소한으로 이동해야하는 거리) + 이때까지 이동한 거리 > k이면, 더이상 탐색을 진행해도 k거리만큼 이동해 도착지점에 못가기 때문에 탐색을 멈추고, backtracking.
2. 현재 위치가 종료 지점이고, (k - 현재까지 이동한 거리)가 홀수이면, 다시 이동한다하더라도 종료지점에 다시 도착할 수 없다. 그러므로 backtracking.
3. 현재 위치가 종료 지점이고, 현재 이동한 거리 == k이면, 결과를 찾은 것이다. 그러므로 종료하고 결과를 출력한다.

위 종료조건 외에도, 다음 이동할 경로를 탐색할 때 사전순의 역순으로 stack에 담기도록 해야한다. (사전순으로 빠른 값이 stack의 최상단에 위치해야 함으로)

위 정의로 아래 코드를 구현하면 답을 구할 수 있다.

### 코드
```python
def solution(n, m, x, y, r, c, k):    
    st, end = (x-1, y-1), (r-1, c-1)
    diff = {"u": (-1, 0), "r": (0, 1), "l": (0, -1), "d": (1, 0)}
    
    stack = [[st, ""]]
    while stack:
        cur, path = stack.pop()
        if abs(end[0]-cur[0]) + abs(end[1]-cur[1]) + len(path) > k:
            continue
        elif end == cur:
            if len(path) == k:
                return path
            elif (k - len(path)) % 2 != 0:
                return "impossible"
    
        for key in diff.keys():
            nxt = (cur[0]+diff[key][0], cur[1]+diff[key][1])
            if 0 <= nxt[0] < n and 0 <= nxt[1] < m and len(path) + 1 <= k:
                stack.append([nxt, path + key])
    
    return "impossible"
```
## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
