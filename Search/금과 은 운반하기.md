tags: `Programmers`, `knapsack`, `Binary Search`
# [Programmers] 금과 은 운반하기 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/86053

ID: yuchem2@gmail.com

Date: 2025.05.16

소요시간: 20

## 1. 문제설명

### 문제
---
어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 a kg과 은 b kg이 전달되어야 합니다.

각 도시에는 번호가 매겨져 있는데, i번 도시에는 금 g[i] kg, 은 s[i] kg, 그리고 트럭 한 대가 있습니다. i번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와 i번 도시만을 왕복할 수 있으며, 편도로 이동하는 데 t[i] 시간이 걸리고, 최대 w[i] kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다.

정수 a, b와 정수 배열 g, s, w, t가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금 a kg과 은 b kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요.


### 제한사항
+ 0 ≤ a, b ≤ 109
+ 1 ≤ g의 길이 = s의 길이 = w의 길이 = t의 길이 = 도시 개수 ≤ $10^5$
  + 0 ≤ g[i], s[i] ≤ $10^9$
  + 1 ≤ w[i] ≤ $10^2$
  + 1 ≤ t[i] ≤ $10^5$
  + a ≤ g의 모든 수의 합
  + b ≤ s의 모든 수의 합

### 예제입출력

| a  | b   | g         | s         | w           | t       | result  |
|----|-----|-----------|-----------|-------------|---------|---------|
| 10 | 10  | [100]     | [100]     | [7]         | [10]    | 50      |
| 90 | 500 | [70,70,0] | [0,0,500] | [100,100,2] | [4,8,1] | 499     |

## 2. 소스코드

### 알고리즘
해당 문제를 보자마자는 백트래킹 기법이 떠올랐으나, 문제의 제한사항을 봤을 때 백트래킹으로 문제를 해결하기에는 너무 많은 시간이 필요하다. 

그래서 다른 방법을 생각해봤다. 이 문제는 일반적인 배낭 문제처럼 제시되어있으나 자세히 살펴보면 배낭 문제가 아닌 것을 확인할 수 있다.

담을 수 있는 배낭의 수가 i만큼 주어지며, 여러번 왕복도 가능하다. 그러므로, 가져올 수 있는 양에 집중하는 것이 아니라 가져오는 시간에 집중을 해서 문제를 풀어보았다.

위 예제입출력에서 2번째 case에서 만약 현재 광물을 이동하는데 12초가 걸렸다고 가정하자. 
+ 0번 도시는 1번 왕복하고, 1번 편도로 이동한다. 즉, 건설 장소에 2번 도착할 수 있는 시간이다. 그러나 0번 도시에 금이 70kg, 은이 0kg이기 때문에 금 70kg를 가져올 수 있다.
+ 1번 도시는 1번 도착할 수 있는 시간이다. 1번 도시에는 금이 70kg, 은이 0kg이기 때문에 금 70kg를 가져올 수 있다.
+ 2번 도시는 6번 왕복할 수 있다. 즉, 건설 장소에 5번 도착할 수 있다. 그러므로 은 10kg를 가져올 수 있다.

위 조건에 따라 12초 동안에는 건설 장소에는 금 140kg와 은 10kg가 올 수 있다. 그러나 문제 조건을 만족하지 않기 때문에 더 많은 시간이 필요하다. 

위 가정에 따라 추가적으로 생각해보면 1000초가 소요된다고 가정하면 금 140kg와 은 500kg를 가져올 수 있다. (2번 도시에서는 최대 은이 500kg가 있기 때문에 500번 왕복해도 최대 은은 500kg밖에 못가져온다.)

---

위 결론으로 생각해볼 수 있는 것은 금, 은의 수를 항상 적절한 양을 가져온다고 가정해 어느 도시에서 무슨 광물을 몇 kg을 가져온다고 생각하지 않아도 된다는 것이다. 충분한 시간이 지나면 항상 도시에 모든 광물을 가져올 수 있고, 필요한 조건을 만족하기 때문이다. 

위 예시에서는 12초인 경우 필요한 조건을 만족하지 않았기 때문에 (은이 부족) 더 많은 시간이 필요하고, 1000초인 경우에는 조건을 만족하고도 시간이 많이 지난 상태이다.

결국, 위 경우에서 우리가 찾는 조건을 만족하는 가장 빠른 시간은 [12:1000] 범위에 존재하게 된다. 이 범위에서 현재 시간에 따라 각 도시에서 가져올 수 있는 광물의 양을 연산하고, 만족한다면 시간을 줄이고, 만족하지 않으면 시간을 늘리면서 찾다보면 가장 빠른 시간을 찾을 수 있다. 

이러한 탐색은 이분 탐색으로 쉽게 구현할 수 있다. 시간의 범위는 제한사항에 따라 상한 값을 $10^{15}$ 으로 정의했다. (a + b의 최대 = $10^9 * 2$, w[i]의 최소 = 1, 최대 왕복 시간 = $10^ 5 * 2$, 최대 시간 = $10^{14} * 4$)

---

현재 시간에서 가져올 수 있는 최대 광물은 다음과 같이 계산할 수 있다. 
+ $왕복 횟수 = 현재 시간 / (2 * t[i])$
+ 도착 횟수는 $현재 시간 mod (2 * t[i]) >= t[i]$인 경우 왕복 횟수 + 1아니면 왕복횟수가 된다.
+ 가져올 수 있는 최대 광물 = min(g[i] + s[i], 도착횟수 * w[i])
+ 가져올 수 있는 최대 금 = min(g[i], 도착횟수 * w[i])
+ 가져올 수 있는 최대 은 = min(s[i], 도착횟수 * w[i])

모든 도시를 순회하면서 각 위에서 나온 가져올 수 있는 최대 광물, 금, 은 수를 계산해 합산한다. 순회할 때 다음과 같은 조건을 만족하면 순회를 종료하고 만족한다고 판단한다. 
+ 최대 광물의 수 합산 >= a + b
+ 최대 금의 수  합산 >= a
+ 최대 은의 수 합산 >= b



### 코드
```python
def solution(a, b, g, s, w, t):
    def check(time):
        total, totalA, totalB = 0, 0, 0 # 매 도시 최대 무게 누적, 금 무게 누적, 은 무게 누적
        for i in range(len(g)):
            repeat = time // (2 * t[i]) 
            if time % (2 * t[i]) >= t[i]: 
                repeat += 1
            max_w = repeat * w[i]
            total += min(max_w, g[i] + s[i])
            totalA += min(max_w, g[i])
            totalB += min(max_w, s[i])
            if total >= a + b and totalA >= a and totalB >= b: 
                return True
        return False
    
    
    st, end = 1, 10 ** 15
    while st < end:
        mid = (st + end) // 2
        if check(mid):
            end = mid
        else:
            st = mid + 1
    
    return st
```
## 3. 개선점

## 4. 개선사항

## 5. 개선사항 평가
