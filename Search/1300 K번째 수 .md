tags: `BOJ`, `Implementation`, `Search`, `Binary Search`
# [BOJ] 1300번 K번째 수 (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.06.02
## 1. 문제설명
| 시간 제한 | 메모리 제한 |  제출   |  정답   | 맞은 사람 |  정답 비율  |
| :---: | :----: | :---: | :---: | :---: | :-----: |
|  2초   | 128MB  | 34078 | 12340 | 9067  | 37.356% |

### 문제
---
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.
### 입력
---
첫째 줄에 배열의 크기 N이 주어진다. N은 $10^5$보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min($10^9, N^2$)보다 작거나 같은 자연수이다.
### 출력
---
B[k]를 출력한다.
### 예제입력1
```
3
7
```
### 예제출력1
```
6
```
## 2. 소스코드

### 알고리즘
이 문제에서 주어진 배열의 최솟값은 1이고, 최댓값은 $N^2$이다. 그러므로 이 범위를 통해 이분탐색을 진행한다.  
가장 중요한 문제는 구한 수보다 작은 값의 개수를 확인하는 것이다.  
일반적인 방법으로 수를 하나하나 세면, O($N^2$)이 걸리기 때문에 이를 줄일 필요가 있다.  
먼저 기본적으로 배열의 각 행에는 최대 n개의 수가 존재한다. 각 행의 최댓값, 즉 각 행의 n열 원소보다 수가 큰 경우에는 최대 n개의 수가 그 수보다 작다.  
아닌 경우에는 n//i (이때 i는 행의 index)만큼의 수가 그 수보다 작거나 같다. 이 값을 그대로 사용한다면, 그 수가 배열에 존재하는 경우 같은 수도 세게 된다.    
그러므로 (n-1)//i만큼의 수가 그 수보다 작다고 한다. 즉, 각 행에 대해 연산을 수행하면서 O(n)으로 줄일 수 있다.  

구해진 작은 수의 수에 따라 l, r을 update하며 이분탐색을 수행하면, 답을 구할 수 있다.  


### 코드
```Python
def problem1300():
    n = int(input())
    k = int(input())
    l, r = 1, min(10**9, n*n)

    while l <= r:
        m = (l+r)//2
        cnt = 0
        for i in range(1, n+1):
            cnt += min((m-1)//i, n)
        if cnt >= k:
            r = m - 1
        else:
            l = m + 1
    print(r)


if __name__ == '__main__':
    problem1300()
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 736ms | 353B |

## 3. 개선점
x
## 4. 개선사항
x
## 5. 개선사항 평가
x
