tags: `BOJ`, `Graph`, `DFS/BFS`
# [BOJ] 9663번 N-Queen (PYTHON)
백준온라인저지(BOJ) https://www.acmicpc.net/

ID: yuchem2

Date: 2023.03.23
## 1. 문제설명
| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 10초 | 128MB  | 91312 | 43846 | 28458 | 46.681% |

### 문제
---
N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.
### 입력
---
첫째 줄에 N이 주어진다. (1 ≤ N < 15)
### 출력
---
첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.
### 예제입력1
```
8
```
### 예제출력1
```
92
```
## 2. 소스코드

### 알고리즘
기본적인 N-Queen 문제 풀이 방법을 이용해 문제를 풀었다. N-Queen 문제에서 퀸이 서로 공격하지 못하는 경우는 다음과 같다.
+ 각 퀸은 같은 행, 열에 있으면 안된다.
+ 각 퀸은 같은 대각선에 위치하면 안된다.  

해당 조건을 기준으로 DFS 방식을 이용해 문제를 풀이하였다.  
일반적인 N-Queen 문제는 모든 답을 찾는 것이 아닌 가능한지 가능하지 않은지 판단하는 문제이지만 이 문제에서는 모든 경우의 수를 출력하여야 한다.  
그러므로 모든 경우를 전부 살펴보아야 하므로 시간이 오래 걸린다.  

### 코드
```python 
n = int(input())
result = [0]
solution = [0] * n

def IsConflict(x):
    for i in range(x):
        if solution[x] == solution[i] or abs(solution[x] - solution[i]) == abs(x - i):
            return True
    return False

def NQueen(x):
    if x == n:
        result[0] += 1
        return

    for i in range(n):
        solution[x] = i
        if not IsConflict(x):
            NQueen(x+1)


NQueen(0)
print(result[0])
```
BOJ에서 Python으로 컴파일 한 결과 시간초과가 발생하였으나 PyPy3으로 실행했을 때 정답처리로 진행되었다. 
| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 204244KB | 29896ms | 419B |

## 3. 개선점

### 문제점
앞서 말했듯이 원래 N-Queen 문제는 가능 여부만 판단한다. 하지만 이 문제에서는 모든 경우를 살펴보게 된다.
Python이 C나 java에 비해 비교적 시간이 오래 걸리므로 Python에서 시간 초과가 발생하지 않고 풀 수 있는 방법을 고민하였다.  
해당 코드를 복기해 본 결과 IsConflict 함수에서 많은 시간을 소요하게 된다. O(n)시간을 소요하고, 이 부분이 모든 재귀에서 다시한번 O(n) 참조하게 된다.  
즉 각 재귀는 최악의 경우 O(n^2)만큼 시간을 소요한다. 반복 대치 방법으로 시간복잡도를 계산하게 되면 O(n^3)이 된다.  
cubic 형태이므로 상당한 시간을 소요한다는 것을 알 수 있다.

### 개선점
이 문제에서 시간을 단축할 수 있는 방법은 IsConflict 함수 부분의 시간복잡도를 O(1)로 만드는 것이다. 그러면 총 시간 복잡도는 O(n^2)이 되게 된다.  
이를 위해서는 충돌조건을 한번에 판단할 수 있는 방법이 필요하다.  

앞서 우리는 행과 열이 충돌한다는 점은 직관적으로 배열의 인덱스를 통해 판단할 수 있다.
이를 통해 대각선이 충돌한단느 정보도 동일하게 직관적으로 판단할 수 있다면 충돌판단이 O(1)이 걸릴 것이다.  
체스판은 정사각형 형태로 존재한다. 이 사각형에는 상향, 하향 대각선이 존재하고 NxN체스판에서 각각 총 2N-1개가 존재하게 된다.
이때 대각선은 하나의 성분만 가지고 있어도 하나의 대각선으로 인지한다.  

이를 통해 4x4 체스판의 경우에서 생각해보면 하향 대각선은 다음과 같이 존재한다. 
1. (0, 0), (1, 1), (2, 2,), (3, 3)을 경유하는 대각선 (0)
2. (0, 1), (1, 2), (2, 3)을 경유하는 대각선 (-1)
3. (0, 2), (1, 3)을 경유하는 대각선 (-2)
4. (1, 0), (2, 1), (3, 2)을 경유하는 대각선 (1)
5. (2, 0), (3, 1)을 경유하는 대각선 (2)
6. (0, 3)만을 경유하는 대각선(-3)
7. (3, 0)만을 경유하는 대각선(3)

각 대각선을 경유하는 칸들의 x, y 값의 차이는 동일하다. 이를 통해 봤을 때 각 대각선의 인덱스는 x-y+N-1로 정의할 수 있다. (이때 x, y는 체스판의 x, y축 값이다.)

같은 방법으로 상향 대각선을 판단하면 다음과 같다. 
1. (0, 3), (1, 2), (2, 1), (3, 0)을 경유하는 대각선(3)
2. (0, 2), (1, 1), (2, 0)을 경유하는 대각선(2)
3. (0, 1), (1, 0)을 경유하는 대각선(1)
4. (1, 3), (2, 2), (3, 1)을 경유하는 대각선(4)
5. (2, 3), (3, 2)을 경유하는 대각선(5)
6. (0, 0)만을 경유하는 대각선(0)
7. (3, 3)만을 경유하는 대각선(6)

각 대각선을 경유하는 칸들의 x, y값의 합은 동일하다. 이를 통해 봤을 때 각 대각선의 인덱스는 x+y로 정의할 수 있다. 

이렇게 대각선을 배열로 일반화해 저장한다면 충돌 여부 검사에는 O(1)이 걸린다. 

## 4. 개선사항
```Python
import sys
sys.setrecursionlimit(10 ** 6)

def NQueen(x):
    global cnt
    if x == n:
        cnt += 1
        return

    for i in range(n):
        if not (row[i] or risingDiagonal[x + i] or fallingDiagonal[x - i + n - 1]):
            row[i] = risingDiagonal[x + i] = fallingDiagonal[x - i + n - 1] = 1
            NQueen(x+1)
            row[i] = risingDiagonal[x + i] = fallingDiagonal[x - i + n - 1] = 0

n = int(input())
cnt = 0
row = [0] * n
risingDiagonal = [0] * (2 * n - 1)
fallingDiagonal = [0] * (2 * n - 1)
NQueen(0)
print(cnt)
```

| 결과 | 메모리 | 시간 | 코드길이 |
|:---:|:-----: | :---: | :----: |
| 맞았습니다 | 31256KB | 25196ms | 534B |

## 5. 개선사항 평가

위의 방식으로 풀었을 때 의미있는 시간 단축이 일어났다. PyPy3가 아닌 Python을 통해서도 BOJ에서 시간초과가 발생하지 않는다. 
