tags: `Programmers`, `Graph`
# [Programmers] 미로주행 테스트 (PYTHON)
Programmers 코딩테스트 연습: https://school.programmers.co.kr/learn/courses/30/lessons/214295

ID: yuchem2@gmail.com

Date: 2024.10.23, 2024.10.29

소요시간: 1시간, 1시간

## 1. 문제설명

### 문제
---
현대모비스에서는 운전자와 탑승자의 편의를 위한 인포테인먼트 헤드유닛이 탑재되어 있습니다. 인포테인먼트 헤드유닛은 운전자와 탑승자에게 차량내/외의 다양한 정보를 제공하면서 동시에 내비게이션, 음성인식, 텔레매틱스 서비스, 멀티미디어 기능 등 엔터테인먼트 및 편의 서비스를 통합적으로 제공하는 기기입니다.

n × m 직사각형 격자 모양의 도로가 나 있는 미로가 있습니다. 미로에서 왼쪽 아래 구석의 좌표는 (0, 0), 오른쪽 위 구석의 좌표는 (n, m) 입니다. 정수 좌표 (a, b)에는 표지판이 있습니다. 자동차의 내비게이션 기능과 차량의 주행 능력을 검증하기 위해 미로의 다양한 위치에서 출발하여 표지판까지 최단 경로를 따라 이동한 테스트 기록이 있습니다. 각 테스트는 출발점의 좌표, 남은 연료량에 따른 최대 주행 거리, 표지판 도달 여부가 기록되어 있습니다. 출발점의 위치와 표지판의 위치가 같을 수 있으며, 이때는 최대 주행 거리에 상관없이 항상 표지판에 도달한 것으로 간주합니다.

테스트 기록을 토대로 표지판의 위치를 알아내려 합니다. 예를 들어 n = 3, m = 5이고 테스트 기록이 다음과 같은 경우를 생각해 봅시다.

| 번호  | 출발점 좌표 | 최대 주행 거리 | 표지판 도달 여부 |
| --- | ------ | -------- | --------- |
| #1  | (2, 3) | 2        | O         |
| #2  | (1, 0) | 4        | X         |
| #3  | (0, 4) | 1        | X         |

이때 표지판이 있을 수 있는 좌표는 (2, 4), (2, 5), (3, 3), (3, 4)의 4개입니다.

격자의 가로 길이 n, 세로 길이 m, 테스트 기록을 나타내는 2차원 정수 배열 tests가 매개변수로 주어집니다. 표지판이 있을 수 있는 좌표의 개수를 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
+ 3 ≤ n ≤ 10^9
+ 3 ≤ m ≤ 10^9
+ 1 ≤ tests의 길이 ≤ 250,000
  + tests의 원소는 [x, y, d, flag] 형태의 길이가 4인 정수 배열입니다.
  + 출발점의 좌표가 (x, y), 최대 주행 거리가 d이고, flag가 1인 경우 표지판에 도달했음을, 0인 경우 표지판에 도달하지 못했음을 의미합니다.
  + 0 ≤ x ≤ n
  + 0 ≤ y ≤ m
  + 0 ≤ d ≤ n + m
  + 0 ≤ flag ≤ 1
  + 표지판이 있을 수 있는 좌표가 하나 이상 존재합니다.
### 예제입출력

| n     | m     | tests                                                                                        | result     |
| ----- | ----- | -------------------------------------------------------------------------------------------- | ---------- |
| 3     | 5     | [[2, 3, 2, 1], [1, 0, 4, 0], [0, 4, 1, 0]]                                                   | 4          |
| 99999 | 99999 | [[0, 0, 199997, 1]]                                                                          | 9999999999 |
| 99999 | 99999 | [[50000, 50000, 3, 0]]                                                                       | 9999999975 |
| 300   | 100   | [[123, 28, 124, 1], [183, 22, 34, 0], [188, 81, 116, 1], [167, 53, 33, 0], [125, 55, 20, 0]] | 6535       |

## 2. 소스코드

### 알고리즘
문제를 다음과 같이 접근하였다.
1. 주어진 출발점으로부터 최대 주행 거리만큼 이동할 수 있는 좌표를 구한다
2. flags에 따라 구분해 1인 경우 끼리 교집합. 0인 경우 끼리 합칩합을 구한다.
3. 전체와 1인 경우의 교집합에서 0인 경우의 차집합을 빼면, 남은 좌표들이 표지판이 있을 수 있는 좌표이다.

해당 방법을 아래와 같은 코드로 작성해 구했다. 하지만 문제에서 주어지는 최대 좌표평면이 $10^9 * 10^9$ 이기때문에 시간초과가 날 것은 당연했다.
아래 코드를 제출한 결과 시간초과가 발생한 부분 외에는 모두 정답이 나왔지만 대부분의 테스트 케이스가 모두 시간초과가 발생하였다. (11.4/100)

```python
from itertools import product

def get_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solution(n, m, tests):
    def find_coordinates(st, d):
        result = set()
        for nxt in product(range(st[0]-d, st[0]+d+1), range(st[1]-d, st[1]+d+1)):
            if get_distance(st, nxt) <= d and 0 <= nxt[0] <= n and 0 <= nxt[1] <= m:
                result.add(nxt)
        return result
    
    answer = 0
    true_sets = set()
    false_sets = set()
    for x, y, d, flag in tests:
        if flag == 1:
            if true_sets:
                true_sets &= find_coordinates((x, y), d)
            else:
                true_sets |= find_coordinates((x, y), d)
        else:
            false_sets |= find_coordinates((x, y), d)
    
    if not true_sets:
        answer = (n+1)*(m+1) - len(false_sets)
    else:
        answer = len(true_sets - false_sets)
        
    return answer
```

다른 방법 혹은 좌표를 구하는 부분을 감소시킬 필요가 존재했다.

#1 아이디어. 외각좌표만 구해 영역을 만든 뒤 계산. -> 마름모꼴이라 외곽 자표가 훨씬 많다..?
### 코드
```
```
## 3. 개선점

## 4. 개선사항

## 5. 개선사항 평가
